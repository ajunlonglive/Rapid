<?xml version="1.0" encoding="UTF-8" ?>
<controls xmlVersion="2"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="../schemas/control.xsd">

	<!-- 
	
	    Copyright (C) 2021 - Gareth Edwards / Rapid Information Systems 
	
		gareth.edwards@rapid-is.co.uk 
	
	
		This file is part of the Rapid Application Platform Rapid is free software: 
		you can redistribute it and/or modify it under the terms of the GNU General 
		Public License as published by the Free Software Foundation, either version 
		3 of the License, or (at your option) any later version. The terms require 
		you to include the original copyright, and the license notice in all redistributions. 
		This program is distributed in the hope that it will be useful, but WITHOUT 
		ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
		FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
		You should have received a copy of the GNU General Public License in a file 
		named "COPYING". If not, see <http://www.gnu.org/licenses/>. 
		
	-->

	<control>

		<type>grid</type>
		<name>Grid</name>
		<image>images/grid.svg</image>
		<helpHtml>A structure for the layout of controls according to rows and columns.</helpHtml>

		<addToNewApplications>true</addToNewApplications>
		<addToNewFormApplications>false</addToNewFormApplications>

		<canUserAdd>true</canUserAdd>
		<canUserMove>true</canUserMove>
		<canUserAddPeers>true</canUserAddPeers>

		<properties>

			<property>
				<key>name</key>
				<name>Name</name>
				<changeValueJavaScript>text</changeValueJavaScript>
				<helpHtml>Name that can be given to the control. Names are used to help identify controls uniquely.</helpHtml>
			</property>

			<property>
				<key>label</key>
				<name>Form summary label</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>formText</changeValueJavaScript>
				<helpHtml>Summary label to appear at the end of the form. Leave blank to have the control and its value hidden.</helpHtml>
			</property>

			<property>
				<key>columnHeadings</key>
				<name>Column headings</name>
				<setConstructValueFunction>return true;</setConstructValueFunction>
				<changeValueJavaScript>checkbox</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Sets whether the grid will use headings or not.</helpHtml>
			</property>

			<property>
				<key>columns</key>
				<name>Columns</name>
				<setConstructValueFunction>return [];</setConstructValueFunction>
				<changeValueJavaScript>gridColumns</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Sets the different columns to be used by the grid. Multiple can be set or removed here and each can be customised.</helpHtml>
			</property>

			<property>
				<key>multiSelect</key>
				<name>Multi-select?</name>
				<setConstructValueFunction>return false;</setConstructValueFunction>
				<changeValueJavaScript>checkbox</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Whether to show a first column of checkboxes to allow multiple rows in the grid to be selected.</helpHtml>
			</property>

			<property>
				<key>dataStorageType</key>
				<name>Data store type</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","None"],["L","Local storage"],["S","Session storage"],["P","Page storage"]];
					]]>
	            </getValuesFunction>
				<helpHtml>Sets the method of data storage. Page storage is for as long as the page is open, session is for as long as the tab/window is open and local is for files to be stored locally on devices.</helpHtml>
			</property>

			<property>
				<key>scrollH</key>
				<name>Scroll horizontal</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
				<refreshHtml>true</refreshHtml>
				<refreshProperties>true</refreshProperties>
				<helpHtml>Sets the horizontal scrollbar.</helpHtml>
			</property>

			<property>
				<key>scrollWidth</key>
				<name>Width</name>
				<changeValueJavaScript>gridScrollWidth</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
			</property>

			<property>
				<key>scrollV</key>
				<name>Scroll vertical</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
				<refreshHtml>true</refreshHtml>
				<refreshProperties>true</refreshProperties>
				<helpHtml>Sets the vertical scrollbar.</helpHtml>
			</property>

			<property>
				<key>scrollHeight</key>
				<name>Height</name>
				<changeValueJavaScript>gridScrollHeight</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>The total height that the table will be fixed to. Can be just a number in which case px will be added.</helpHtml>
			</property>

			<property>
				<key>fixedHeader</key>
				<name>Fixed header</name>
				<changeValueJavaScript>gridScrollFixedHeader</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Whether the header row will not scroll with the other rows.</helpHtml>
			</property>

			<property>
				<key>advancedProperties</key>
				<name>Advanced properties</name>
				<setConstructValueFunction>return false;</setConstructValueFunction>
				<changeValueJavaScript>checkbox</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Whether to show advanced properties to actions.</helpHtml>
			</property>

		</properties>

		<resources>

			<resource>
				<type>cssFile</type>
				<contents>styles/fonts/fontawesome/css/font-awesome.css</contents>
			</resource>

			<!-- Some browsers choose the tff instead of the woff so both are included -->
			<resource>
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fa-solid-900.woff</contents>
	        </resource>
	        <resource>
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fa-solid-900.woff2</contents>
	        </resource>
	        <resource>
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fa-solid-900.ttf</contents>
	        </resource>

			<resource>
				<type>css</type>
				<contents>
	                <![CDATA[	                
table.grid {
	border-collapse:collapse;
}          

table.grid td {
	border: 0;
}     

table.grid span.sort {
	font-family: FontAwesome-solid;
	margin-left: 5px;
}

div.gridScroll {
	display: inline-block;
}

div.gridScroll table {
	width: 100%;
}

div.gridScrollHeader {
	overflow-x: hidden;
	overflow-y: hidden;
}

div.gridScrollHeader table.grid tr:not(:first-child) {
	visibility: hidden; /* must be hidden rather than display none to still have geometry to stay in sync with body */
}

div.gridScrollBody table.grid tr:first-child {
	visibility: hidden; /* must be hidden rather than display none to still have geometry to stay in sync with header  */
}

[disabled] table.grid tr td {
	cursor: not-allowed;
}
	                ]]>
				</contents>
			</resource>

			<resource>
				<type>javascript</type>
				<contents>
	                <![CDATA[
	                
var _gridLoaders = {};	                
	                
function getGridDataStoreData(id, details) {
	data = null;
	dataString = null;
	switch (details.dataStorageType) {
		case "L" :
			dataString = localStorage[_appId + id];
		break;
		case "S" :
			dataString = sessionStorage[_appId + id];
		break;
		case "P" :
			dataString = window[id + "datastore"];			
		break;
	}
	if (dataString) {
		data = JSON.parse(dataString);
		if (data) {
			if (!data.fields) data.fields = [];
			if (!data.rows) data.rows = [];
		}
	}
	return data;
}

function saveGridDataStoreData(id, details, data) {
	switch (details.dataStorageType) {
		case "L" :
			localStorage[_appId + id] = JSON.stringify(data);
		break;
		case "S" :		
			sessionStorage[_appId + id] = JSON.stringify(data);
		break;
		case "P" :
			window[id + "datastore"] = JSON.stringify(data);
		break;
	}
}	

function sortGridByColumn(ev, id, details, column, asc) {

	// check we have details and this column
	if (details && details.columns && details.columns[column]) {

		// get the grid data
		var data = getData_grid(ev, id, null, details);
			
		// get the field
		var field = details.columns[column].field;
		
		// assume data and details columns are the same
		var dataColumn = column;
		
		// check the column matches the field
		if (data.fields[column] != field) {
			// didn't match so find what it should be
			for (var i in data.fields) {
				if (data.fields[i] && field && data.fields[i].toLowerCase() == field.toLowerCase()) {
					dataColumn = i;
					break;
				}
			}	
		}
	
		// check there is data for the column
		if (data && data.rows && data.fields[dataColumn]) {
		
			// an array for all values in this column
			var sortedValues = [];
			// populate the array for each row with an object with the original index and value
			for (var i in data.rows) sortedValues.push( {index:i, value:data.rows[i][dataColumn]} );
			
			// if selected rows
			if (data.selectedRowNumber) {
				// if old-style single value or array
				if ($.isArray(data.selectedRowNumber)) {
					// loop selected row numbers
					for (var i = 0; i < data.selectedRowNumber.length; i++) {
						// get the selected row number
						var selectedRowNumber = data.selectedRowNumber[i] - 1;
						// mark value as selected if possible
						if (data.selectedRowNumber >= 0 && sortedValues.length > selectedRowNumber) sortedValues[selectedRowNumber].selected = true;
					}
				} else {
					// mark value as selected
					if (data.selectedRowNumber > 0 && sortedValues.length >= data.selectedRowNumber) sortedValues[data.selectedRowNumber - 1].selected = true;
				}
			}
			
			// determin the sort type
			switch (details.columns[column].sort) {
				// for n, turn both values into numbers and use that
				case "n" : sortedValues.sort( function(i1, i2) {
					var v1 = i1.value;
					if (v1) v1 = parseFloat(v1.replaceAll(",",""));
					var v2 = i2.value;
					if (v2) v2 = parseFloat(v2.replaceAll(",",""));
					return v1 - v2; 
				});			
				break;
				// d1 is uk date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make dates
						var d1 = new Date(d1Parts[2], d1Parts[1]-1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], d2Parts[1]-1, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d2 is uk month-word date format
				case "d2": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// get the months
						var months = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"];
						for (m1 in months) if (d1Parts[1].toLowerCase().substr(0,3) == months[m1]) break;
						for (m2 in months) if (d2Parts[1].toLowerCase().substr(0,3) == months[m2]) break;
						// make the dates
						var d1 = new Date(d1Parts[2], m1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], m2, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d3 is us date format
				case "d3": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make the dates
						var d1 = new Date(d1Parts[2], d1Parts[0]-1, d1Parts[1]);
						var d2 = new Date(d2Parts[2], d2Parts[0]-1, d2Parts[1]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d4 is xml date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// make the dates
						var d1 = new Date(d1Parts[0], d1Parts[1]-1, d1Parts[2]);
						var d2 = new Date(d2Parts[0], d2Parts[1]-1, d2Parts[2]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// for c, make a new function from the sortFunction property and use that
				case "c":
					var f = new Function("item1","item2",details.columns[column].sortFunction);
					sortedValues.sort(f);				
				break;
				default : sortedValues.sort( function(i1, i2) {				
					// easy one's first
					if (i1.value == null) {				
						return 1;
					} else if (i2.value == null) {
						return -1;
					} else {
						// assume the values match
						var s = 0;
						// get both values in lower case
						v1 = i1.value.toLowerCase();
						v2 = i2.value.toLowerCase();
						// only if the two are different
						if (v1 != v2) {			
								// get the shortest length
								var l = Math.min(v1.length, v2.length);
								// loop the shortest length
								for (var i = 0; i < l; i++) {
									// check the different in ascii values
									if (v1.charCodeAt(i) > v2.charCodeAt(i)) {
										s = 1;
										break;
									} else if (v1.charCodeAt(i) < v2.charCodeAt(i)) {
										s = -1;
										break;
									}					
								}
								// if s is still zero use the length of the strings
								if (s == 0) s = v1.length - v2.length;			
						} // same check
						return s
					} // null checks					
				}); 
			}
					
			// create a new rows array
			var rows = [];
			// created a bew selectedRowNumber array
			var selectedRowNumber = [];
			// if ascending
			if (asc) {
				// loop the returned sorted column values
				for (var i in sortedValues) {
					// add into the rows array from their original position
					rows.push(data.rows[sortedValues[i].index]);
					// if this value was selected add it's new position
					if (sortedValues[i].selected) selectedRowNumber.push(i*1 + 1);
				}
			} else {
				// loop the returned sorted column values in reverse
				for (var i in sortedValues) {
					// and add into the rows array from their original position
					rows.push(data.rows[sortedValues[sortedValues.length - i - 1].index]);
					// if this value was selected add it's new position
					if (sortedValues[i].selected) selectedRowNumber.push(sortedValues.length - i);
				}
			}
			// replace the data rows with the placed rows
			data.rows = rows;
			// replace the selectedRowNumber if need be
			if (selectedRowNumber.length) data.selectedRowNumber = selectedRowNumber;
			// set the sorted data
			setData_grid(ev, id, null, details, data);
		}
	}
} 

// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = -1;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row of the correct grid
	if (row[0] && row.closest("#" + id)[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
		// get the position of relevant row
		index = rows.index(row);
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// index is the row with the selected style within the grid
		index = grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(grid.find("tr.rowSelect"));			
	}
	if (index > -1) index ++;
	return index;
}

// gets the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRow(id, ev) {
	// assume we're not going to find it
	var row = null;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// row is .rowSelect
	row = grid.find("tr.rowSelect").not("[data-ignore]");
	return row;
}


// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMultiSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = null;
	// get the table using the id
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// get any rowSelect rows
	var rows = grid.find("tr.rowSelect").not("[data-ignore]");
	// if we got some
	if (rows.length > 0) {
		// make index an array
		index = [];
		// for each row
		rows.each( function(i){
			// add to index
			index.push(grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(this) + 1);
		});
	}
	return index;
}

// gets the selected rows, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMutiSelectedRows(id, ev) {
	// assume we're not going to find any
	var rows = null;
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// rows have .rowSelect and not data-ignore
	rows = grid.find("tr.rowSelect").not("[data-ignore]");			
	// return
	return rows;
}

// selectively un-escapes html escape sequences which are escaped for us in in the setter .html(value), but not unescaped in the getter .html()
function getGridUnescapedValue(value) {
	// if the value is present and a string
	if (value && $.type(value) === "string") {
		// un-escape common escape sequences
		value = value.replaceAll("&lt;","<")
		            .replaceAll("&gt;",">")
		            .replaceAll("&amp;","&");
		// if the value looks like JSON
		if (value[0] === "{" && value[value.length - 1] === "}") {
			try {
				value = JSON.parse(value);
			} catch(e) {}
		}
	}
	// return
	return value;
} 

// global function to set the grid header multi-select, used in both control init, and dynamic column header add
function setGridHeaderMultiSelect(id, grid) {
	// this must fire before the row click
	$("#" + id).find("input.gridMultiSelectHeader").click(function(ev) {
		// get the header value
		var select = $(this).prop("checked");
		// update rowSelect accordingly
		if (select) {
			// select all rows, except the top one
			grid.find("tr:not(:first-child)").addClass("rowSelect");
		} else {
			// remove select from all rows
			grid.find("tr").removeClass("rowSelect");
		}
		// update row checkboxes
		grid.find("input.gridMultiSelect").prop("checked",select);
	});
}     	
	                ]]>
	            </contents>
			</resource>
		</resources>

		<getHtmlFunction>
	        <![CDATA[ 
var headerHtml = "<tr" + (this.columnHeadings ? "" : " style='display:none'") + ">";
var rowHtml = "<tr>";
if (this.multiSelect) {
	headerHtml += "<td><input type='checkbox' class='gridMultiSelectHeader'/></td>";
	rowHtml += "<td><input type='checkbox' class='gridMultiSelect'/></td>";
}
if (this.columns.length > 0) {	
	var columnCount = 0;
	for (var i in this.columns) {
		var column = this.columns[i];
		if (column.visible) {
			headerHtml += "<td" + (column.titleStyle ? " style='" + escapeApos(column.titleStyle) + "'" : "") + ">" + column.title;
			if (column.sort) headerHtml += "<span class='fas sort'>&#xf0dc;</span>";
			headerHtml += "</td>";
			if (i % 2 == 1) {
			 	rowHtml += "<td " + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">123.00</td>"
			} else {
				rowHtml += "<td" + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">Data</td>"
			}
			columnCount ++;
		} else {
			headerHtml += "<td style='display:none;'>" + column.title + "</td>";
			rowHtml += "<td style='display:none;'></td>"
		}
	}
} else {
	headerHtml += "<td>No columns</td>";
	rowHtml += "<td>No columns</td>";
}
rowHtml += "</tr>";
headerHtml += "</tr>";
	                
// check for scrolling
if (this.scrollH || this.scrollV) {
	// return a container div with the table inside
	return "<div id='" + this.id + "' style='display:inline-block;" + (this.scrollH ? "overflow-x:" + this.scrollH + ";max-width:" + this.scrollWidth + ";" : "") + (this.scrollV && !this.fixedHeader ? "overflow-y:" + this.scrollV + ";max-height:" + this.scrollHeight + ";" : "") + "' class='gridScroll" + getStyleClasses(this) + "'><table class='grid" + (this.multiSelect ? " multiSelect" : "") + "' style='margin:0;'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table></div>";
} else {
	// return a simple table
	return "<table id='" + this.id + "' class='grid" + (this.multiSelect ? " multiSelect" : "") + getStyleClasses(this) + "'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table>";
}
	        ]]>
	    </getHtmlFunction>

		<initDesignJavaScript>
	   		<![CDATA[
// upgrade any previous version styles to this version to include the header
if (this.styles && this.styles.length > 0) {
	// get the id
	var id = this.id;
	for (var i =0; i < this.styles.length; i++) {
		// get the style
		var style = this.styles[i];
		// if this is one to upgrade do so
		if (style.appliesTo == "#" + id) this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child td") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child td", rules: style.rules});
	}
}
	   		]]>
	   </initDesignJavaScript>

		<saveJavaScript>
	        <![CDATA[
// get our object
var table = this.object;
if (!table.is("table")) table = table.find("table").last();
// check if columns have been defined
if (this.columns && this.columns.length > 0) {
	// remove all sample rows, leaving the header row
	table.children().last().children(":not(:first)").remove();
} else {
	// if there are no columns, remove the header row as this will be populated by the fields
	table.children().last().children().remove();
}
// if we have datastorage of type P, turn off canBeUsedFromOtherPages
if (this.dataStorageType == "P") this.canBeUsedFromOtherPages = false;  
	        ]]>
	    </saveJavaScript>

		<getDetailsFunction>	        
	        <![CDATA[
var details = {type: this.type, columnHeadings:this.columnHeadings};
if (this.columns && this.columns.length > 0) {
	details.columns = [];
	for (var i in this.columns) {
		var column = this.columns[i];
		var c = {};
		if (column.visible) c.visible = column.visible;
		if (column.field) c.field = column.field;
		if (column.fieldStyle) c.style = column.fieldStyle;		
		if (column.sort) c.sort = column.sort;
		if (column.sortFunction) c.sortFunction = column.sortFunction;
		if (column.cellFunction) c.cellFunction = column.cellFunction;			
		details.columns.push(c);
	}
} 	        
if (this.styles && this.styles.length > 0) {
	details.rowHover = false;
	details.rowSelect = false;
	for (var i in this.styles) {
		var style = this.styles[i];
		if (style.appliesTo && style.appliesTo.indexOf("rowHover") > 0) details.rowHover = true;
		if (style.appliesTo && style.appliesTo.indexOf("rowSelect") > 0) details.rowSelect = true;
	}
}
// set multiSelect
if (this.multiSelect) details.multiSelect = true;
// check and set data storage
if (this.dataStorageType) {
	this.canBeUsedFromOtherPages = true;
	details.dataStorageType = this.dataStorageType;
} else {
	this.canBeUsedFromOtherPages = false;
}
// if scrollH set header and width
if (this.scrollH) {
	details.scrollH = this.scrollH;
	details.scrollWidth = this.scrollWidth;
}
// if scrollV set scroll, height, and header
if (this.scrollV) {
	details.scrollV = this.scrollV;
	details.scrollHeight = this.scrollHeight;
	details.fixedHeader = this.fixedHeader;
}
return details;
			]]>	        	        
	    </getDetailsFunction>

		<getDataFunction>
	        <![CDATA[
var data = null;
if (details) {
	// if there is a datastore and the grid is not present in the page    
	if (details.dataStorageType && !$("#" + id)[0]) {
		data = getGridDataStoreData(id, details);
		if (field && data.fields && data.rows && data.rows.length > 0) {
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					data = data.rows[0][i];
					break;
				}
			}
		}
	} else {
		// get the grid
		var grid = $("#" + id);
		// promote to last in case of fixed header
		if (!grid.is("table")) grid = grid.find("table").last();
		// return null if grid is empty
		if (grid.children().length < 1) return data;
		// get the columns from the details
		var columns = details.columns || details.dynamicColumns;
		
		// if we had no columns, must be dynamic, read them from the first row cell contents
		if (!columns) columns = grid.find("tr").first().children().map(function(field) {
			var f = $(this).text(); 
			return { visible: true, field: f }; 
		});
		
		// if a field was specified
		if (field) {
			var row = getGridSelectedRow(id, ev);
			if (row[0]) {
				for (var i in columns) {
					if (columns[i].field && columns[i].field.toLowerCase() == field.toLowerCase()) {
						data = getGridUnescapedValue(row.children(":nth(" + i + ")").html());
						break;
					}
				}
			}	    
			if (data == null && details.dataStorageType) {
				var dataStore = getGridDataStoreData(id, details);
				var rowIndex = getGridSelectedRowNumber(id, ev, details);
				rowIndex --;
				if (field && rowIndex > -1 && dataStore.rows && dataStore.rows.length > rowIndex) {
					for (var i in dataStore.fields) {
						if (dataStore.fields[i] && dataStore.fields[i].toLowerCase() == field.toLowerCase()) {
							data = dataStore.rows[rowIndex][i];
							break;
						}
					}
				}
			}
		} else {
			var data = {};
			data.fields = [];		
			for (var i in columns) {
				var field = columns[i].field;
				if (field !== undefined) data.fields.push(columns[i].field);		
			}
			data.rows = [];
			grid.find("tr:not(:first):not([data-ignore])").each(function(i) {
				var row = [];
				$(this).children().each(function(i) {
					// if applicable remove one from the column index for the multiselect checkbox
					if (details.multiSelect) i--;
					// get the html in the cell
					var html = $(this).html();
					// convert the html to a value
					var value = getGridUnescapedValue(html);
					// add this value to the row if there is a field for it
					if (i >= 0 && columns[i] && columns[i].field !== undefined) row.push(value);
				});
				data.rows.push(row);
			});
			// if there is a data store
			if (details.dataStorageType) {
			    // get the data from the data store
				var dataStore = getGridDataStoreData(id, details);
				// if we got one
				if (dataStore) {
					// make a field map of data from the grid to data from the dataStore
					var fieldMap = {};
					// loop the fields from the control in the page
					for (var i in data.fields) {
						// assume we can't find this field
						var found = false;
						// loop the fields from the dataStore
						for (var j in dataStore.fields) {
							// if this is the field they both have
							if (data.fields[i] && dataStore.fields[j] && data.fields[i].toLowerCase() == dataStore.fields[j].toLowerCase()) {
								fieldMap[i] = j;
								found = true;
								break;
							}							
						}
						// if not found 
						if (!found) {
							//add to dataStore fields
							dataStore.fields.push(data.fields[i]);
							// add to map
							fieldMap[i] = dataStore.fields.length - 1;
						}	
					}
					// loop the rows in the data from the grid
					for (var i in data.rows) {
						// add an empty row to the dataStore rows if there are more in the page
						if (dataStore.rows.length < i - 1) dataStore.rows.push([]);
						// if there are less cells in the rows than it's fields add more
						while (dataStore.rows[i].length < dataStore.fields.length) dataStore.rows[i].push(null);						
						// loop the fieldMap and update dataStore with values from page
						for (j in fieldMap) dataStore.rows[i][fieldMap[j]] = data.rows[i][j];						
					}
					// set data to our merged dataStore
					data = dataStore;	
				} // datastore check							
			} // storage type check
			
			// if multiSelect
			if (details.multiSelect) {
				// get multi selected rows
				data.selectedRowNumber = getGridMultiSelectedRowNumber(id, ev, details);
			} else {
				// get a single selected row
				data.selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
			}
			
		} // field check
	}
}
return data;
			]]>
	    </getDataFunction>

		<setDataJavaScript>
	        <![CDATA[

// clear any existing timeouts for the grid
if (_gridLoaders[id] && _gridLoaders[id].timeouts && _gridLoaders[id].timeouts.length > 0) {
	for (var i in _gridLoaders[id].timeouts) {
		clearTimeout(_gridLoaders[id].timeouts[i]);
	}
}

// create an empty load
_gridLoaders[id] = {timeouts:[]};

// get the grid control	        
var grid = $("#" + id);
// make sure it's the tables
if (!grid.is("table")) grid = grid.find("table");

// if we have a fixed header
if (details.fixedHeader) {
	// if we haven't applied it yet
	if (grid.parent().is(".gridScroll")) {
		// create and style the wrapper
		grid.parent().css({
			"max-height": details.scrollHeight,
			"overflow-y": details.scrollV
		});
	}
}

// if there are columns defined for this grid
if (details.columns) {
	// remove all rows except for the first one (the header)
	grid.find("tr:not(:first-child)").remove();
} else {
	// all rows as the header is dynamic
	grid.find("tr").remove();
	// if there is data and fields map them to dynamic coumns collections
	if (data && data.fields) details.dynamicColumns = data.fields.map(function(field) { return { visible: true, field: field }; });
}
// reset any sort indicators if not being used for sorting
grid.find("span.sort").html("&#xf0dc");
// if we have data
if (data !== undefined && data !== "") {

	// make a data object
	data = makeDataObject(data, field);
	
	// if we have some rows to load
	if (data && data.rows && data.rows.length > 0) {
		
		// retain number of rows we're about to load
		_gridLoaders[id].rows = data.rows.length;
		// retain any selected rows we're about to load
		_gridLoaders[id].selectedRowNumber = data.selectedRowNumber;
		
		// retain that we are loading
		_gridLoaders[id].loading = true;
		
		// the row handler that is shared by grids with columns and those without
		var rowHandler = function(ev) {
			// get the row 
			var row = $(this);
			// if this grid has multiselect things are more confusing
			if (details.multiSelect) {
				// get the target
				var target = $(ev.target);
				// get the grid id
				var id = row.closest("[id]").attr("id");
				// get any table row click handler
				var handler = window["Event_click_" + id];
				// if we're here because we clicked the gridMultiSelect checkbox - in this case row selection is done in the input click listener, above, also do nothing is cell around the multiselect clicked
				if (!target.is("input.gridMultiSelect") && !target.children("input.gridMultiSelect")[0]) {
					// if there is a handler clicking off the checkbox must select just the clicked on row and fire the handler for the one row, if no hander the row click can act like the checkbox
					if (handler) {
						// remove rowSelect class from all rows in the table
						row.parent().find("tr.rowSelect").removeClass("rowSelect");
						// add rowSelect to this row
						row.addClass("rowSelect");
						// uncheck all inputs, what happens next is the handler fires and the selected row is just this one
						grid.find("input.gridMultiSelectHeader, input.gridMultiSelect").prop("checked", false);
						// check this one
						target.closest("tr").children().first().find("input.gridMultiSelect").prop("checked", true);
					} else {
						// toggle this rows checkbox by firing it's click event
						target.closest("tr").children().first().find("input.gridMultiSelect").first().click();
					}
				}
			} else {
				// remove rowSelect class from all rows in the table
				row.parent().find("tr.rowSelect").removeClass("rowSelect");
				// add rowSelect to this row
				//row.addClass("rowSelect");
				var e = row.get(0);
				e.className = e.className + " rowSelect";
			}
		}
		
		// a function for selecting rows
		var rowSelect = function(data, rowObject, rowIndex) {
			// if there is a selected row
			if (data.selectedRowNumber) {
				// check for array, used by multi-select
				if ($.isArray(data.selectedRowNumber)) {
					// loop array
					for (var i in data.selectedRowNumber) {
						// if this is a selected row 
						if (rowIndex == data.selectedRowNumber[i]-1) {
							// add rowSelect class
							rowObject.addClass("rowSelect");
							// tick any select box
							rowObject.children().first().find("input[type=checkbox].gridMultiSelect").prop("checked",true);
						}
					}
				} else {
					// if this is the selected row
					if (rowIndex == data.selectedRowNumber-1) {
						// add rowSelect class
						rowObject.addClass("rowSelect");
						// tick any select box
						rowObject.children().first().find("input[type=checkbox].gridMultiSelect").prop("checked",true);
					}
				} // array check
			} // data.selectedRowNumber check
		} // rowSelect function
		
		// code like vertical scrolling to be applied by columns and no columns once they have finished rendering
		var afterLoaded = function() {
		
			// if we have vertical scrolling
			if (details && details.scrollV && details.scrollHeight) {
			
				// get scroll height
				var scrollHeight = details.scrollHeight.trim();
				// add px if no other unit specified
				if (parseInt(scrollHeight) + '' == scrollHeight + '') scrollHeight += "px";
			
				// if we have a fixed header
				if (details.fixedHeader) {
				
					// if we haven't applied it yet
					if (!grid.parent().is(".gridScrollBody")) {
						
						grid.parent().css({
							"max-height": "100%",
					    	"overflow-x": "hidden",
					    	"overflow-y": "hidden"
						});
						
					    // create and style the wrapper
					    var oTblDiv = $("<div class='gridScrollBody' />");
					    oTblDiv.css({
					    	"max-width": details.scrollWidth,
					    	"max-height": details.scrollHeight,
					    	"overflow-x": details.scrollH,
					    	"overflow-y": details.scrollV
					    });
					    // wrap it
					    grid.wrap(oTblDiv);
					
					    // clone the original grid
					    var newTbl = grid.clone();
					    // update it's id
					    newTbl.attr("id",id + "header");
					    				
						// set the class on the parent on the new table (this is the grid root)
					    newTbl.parent().addClass("gridScroll");	      
						// get the old table parent
					    var parent = grid.parent();
						// add the new table
					    parent.parent().prepend(newTbl);			    
					    // move the old table parent after the new table
					    parent.insertAfter(newTbl);
					    // wrap the new table
					    var gridScrollHeader = $("<div class='gridScrollHeader' />");
					    newTbl.wrap(gridScrollHeader);
						
						// apply the resizing - which also measures the vertical scrolling heights
						$(window).resize();
						
						var gridScrollHeader = $(".gridScrollHeader");
						var gridScrollBody = $(".gridScrollBody");
						
						if (gridScrollHeader.length && gridScrollBody.length) {
						
							var gridBodyElement = gridScrollBody[0];
							
							var setScrollPosition = function() {
								gridScrollHeader.scrollLeft(gridBodyElement.scrollLeft);
							};
							
							var betweenFrames = false;
							
							$(".gridScrollBody").scroll(function(scrollEvent) {
								if (!betweenFrames) {
									requestAnimationFrame(function() {
										setScrollPosition();
										betweenFrames = false;
									});
									betweenFrames = true;
								}
							});
						}
					    
					} // fixed header applied
					
					// get the header
					
					// if scrollV is yes or auto and present we need to check the height and adjust margin that might not be needed
					if (details.scrollV == "scroll" || $("#" + id).find("div.gridScrollBody").get(0).scrollHeight > $("#" + id).find("div.gridScrollBody").height()) {
						// add some margin for the scroll that we know is there
						$("#" + id).find("div.gridScrollHeader").css({"margin-right":"15px"});
					} else {
						// remove margin for the scroll that we know is not there
						$("#" + id).find("div.gridScrollHeader").css({"margin-right":"0"});
					}
				    
				} // fixed header
						
			} // vertical scrolling
			
			// if we have not applied sorts yet
			if (details && !grid.parent().is(".gridSortsApplied")) {
			
				// assume no headers
				var headers = null;
				// if there is vertical scrolling
				if (details.scrollV && details.scrollHeight && details.fixedHeader) {
					// get the visible header cells
					headers = $("#" + id).find("table").first().find("tr:first-child td");
				} else {
					headers = grid.find("tr:first-child td");
				}
			
				// loop the columns
				for (var i in details.columns) {
					// if it has a sort (but not a fuxed)
					if (details.columns[i].sort) {
						// assume the index is i
						var index = i;
						// if we have multiselect move the index on one
						if (details.multiSelect) index ++;
						// get the header cell - move one on if we have multiselect
						var cell = $(headers.get(index));
						// change the cursor
						cell.css("cursor","pointer");
						// add a listener
						cell.click( {index:index},function(ev) {
							// get the span
							var span = $(ev.target);
							// drill down if need be
							if (!span.is("span")) span = span.find("span");
							// get the column
							var column = ev.data.index;
							// if this is multiselect subtract 1 column
							if (details.multiSelect) column--;
							// if ascending or not set (note the unicode escape)
							if (span.html() == "\uf0de") {
								sortGridByColumn(ev, id, details, column, false);
								span.html("&#xf0dd;");
							} else {
								sortGridByColumn(ev, id, details, column, true);
								span.html("&#xf0de;");
							}
						});
					}
				}
				
				// mark grid as having sorts applied
				grid.parent().addClass("gridSortsApplied");
			
			}
		
		}  // afterLoaded function
		
		// check we have details and columns
		if (details && details.columns && data.fields) {
		
			// header row is added in designer with getHtml method above
		
			// assume no columns (we're about to check)
			var columnMap = [];
			// assume no cell functions
			var cellFunctions = false;
			
			// loop the columns
			for (var i in details.columns) {

				// loop  the fields		
				for (var j in data.fields) {
					var found = false;
					if (details.columns[i].field && data.fields[j]) {
						if (details.columns[i].field.toLowerCase() == data.fields[j].toLowerCase()) found = true;
					} else {
						if (!data.fields[j]) found = true;
					}
					if (found) {
						columnMap.push(j);
						break;
					}
				}
				// added the column to the map
				if (columnMap.length == i) columnMap.push("");
				// if we have cellFunction JavaScript, and it hasn't been turned into a function object yet
				if (details.columns[i].cellFunction) {
					// remember that we have at least one cell function
					cellFunctions = true;
					// if the cell function has not been added to the details object, do so now
					if (!details.columns[i].f) details.columns[i].f = new Function(["id", "data", "field", "details", "value"], details.columns[i].cellFunction);
				}
			}
			
			// get the tbody
			var tbody = $("#" + id).find("tbody");

			// inline function for adding rows which we'll call asychronously from a timer
			var addRows = function(grid, data, rowIndex) {
			
				// loop the chunks rows
				for (var chunkIndex = 0; chunkIndex < 40 && data.rows[rowIndex]; chunkIndex++, rowIndex++) {
				
					// get the row
	 				var row = data.rows[rowIndex];
	
					// start the row object with the styling
	 				var tr = document.createElement("tr");
	 				tr.className = "rowStyle" + (rowIndex % 2 + 1) + (data.rowValidation && i < data.rowValidation.length && !data.rowValidation[i] ? " validation" : "");	 				
	
					// add multiselect
					if (details.multiSelect) {
						var td = document.createElement("td");
						var input = document.createElement("input");
						input.setAttribute("type", "checkbox")
						input.className = "gridMultiSelect"
						td.appendChild(input);
						tr.appendChild(td);
					}
					
					// loop the row cells
					for (var cellIndex in details.columns) {
					
						// add cell with value to row
						var td = document.createElement("td");
						
						// assume the cell has no style rules from the grid details
						var style = "";
						// if column is not visable add display:none
						if (details.columns[cellIndex] && !details.columns[cellIndex].visible) style += "display:none;";
						// if column has a style add it
						if (details.columns[cellIndex] && details.columns[cellIndex].style) style += details.columns[cellIndex].style;
						// if there is a style rule make html attribute for it
						if (style) td.setAttribute("style", style);
										 
						// assume the cell has no value
						var value = "";
						// get the position of this column in the data object
						var mappedCol = columnMap[cellIndex];
						// if we can find the column and it has data use it as the value
						if (mappedCol && row[mappedCol] !== null) value = row[columnMap[cellIndex]];
						// if the value is an object, stringify it
						if ($.isPlainObject(value)) {
							try {
								value = JSON.stringify(value);
							} catch(ex) {}
							// set the value as text
							td.innerText = value;
						} else {
							// set the value as html
							td.innerHTML = value;
						}
						// add the cell
						tr.appendChild(td);
					}
					tbody.append(tr);
	
					// get a jquery reference to the row
					var rowObject = $(tr);
			                       
			        // if there are cell functions to apply to the rows
					if (cellFunctions) {
					
						// loop columns looking for cell functions
						for (var i in details.columns) {
							// if this column has a cell function
							if (details.columns[i].f) {
								// get a reference to the cell (add 1 if multiSelect to account for this column)
								var cellObject = rowObject.children(":nth-child(" + ((details.multiSelect ? 2 : 1) + i*1) + ")");
								// get it's value
								var value = cellObject.html();
								// apply the function to the cellObject!
								details.columns[i].f.apply(cellObject,[id, data, details.columns[i].field, details, value]);
							}
						}
					}
	
					// call the row handler if we click on a row that isn't the first one
					rowObject.click(rowHandler);
					
					// do any row selections
					rowSelect(data, rowObject, rowIndex)

				} // row loop
		
				// if there is a row at the current index
				if (data.rows[rowIndex]) {
					// create a new timeout to add these rows
					var timeoutId = setTimeout(function() { addRows(grid, data, rowIndex); });
					// add timeout to grid loader object
					_gridLoaders[id].timeouts.push(timeoutId);
				} else {
					// update that we've finished loading
					_gridLoaders[id].loading = false;
					// add any after loaded code, like vertical scrolling
					afterLoaded();
					// fire the loaded event
					if (window["Event_gridLoaded_" + id]) window["Event_gridLoaded_" + id](ev);
				}
				
			} // addRows function

			// add the first set of rows on the main thread
			addRows(grid.get(0), data, 0);

		} else {

			// start the header row with the styling
			var headerHtml = "<tr" + (details.columnHeadings == false ? " style='display:none'" : "") + ">";
			// if multiselect
			if (details.multiSelect) headerHtml += "<td><input type='checkbox' class='gridMultiSelectHeader'/></td>";
			// loop the fields
			for (var i in data.fields) {
				// add cell with field to row
				headerHtml += "<td>" + data.fields[i] + "</td>";
			}
			// close the row
			headerHtml += "</tr>";
			
			// append the header html
			grid.append(headerHtml);
			
			// if multiselect apply the header multiselect
			if (details.multiSelect) setGridHeaderMultiSelect(id, grid);
			
			// get the tbody
			var tbody = $("#" + id).find("tbody");
			
			// inline function for adding rows which we'll call asychronously from a timer
			var addRowsSimple = function(grid, rows, rowIndex) {
			
				// loop the rows
		        for (var chunkIndex = 0; chunkIndex < 40 && rows[rowIndex]; chunkIndex++, rowIndex++) {
		            
		            // get the row
		            var row = rows[rowIndex];
		            
		            // start the row object with the styling
		            var tr = document.createElement("tr");
		            tr.className = "rowStyle" + (rowIndex % 2 + 1);

		            // add multiselect
					if (details.multiSelect) {
						var td = document.createElement("td");
						var input = document.createElement("input");
						input.setAttribute("type", "checkbox")
						input.className = "gridMultiSelect"
						td.appendChild(input);
						tr.appendChild(td);
					}
		            
		            // loop the row cells
		            for (var cellIndex in row) {
		                // add cell with value to row
		                var td = document.createElement("td");
		                // get the value
		                var value = row[cellIndex];
		                // if the value is an object, stringify it
						if ($.isPlainObject(value)) {
							try {
								value = JSON.stringify(value);
							} catch(ex) {}
						}
						// update to blank space if null
						if (value === null) value = "";
						// create the td with the value
		                td.innerHTML = value;
		                tr.appendChild(td);
		            }
		            tbody.append(tr);

					// get the rowObject
					var rowObject = $(tr);
	 
					// if we click on a row that isn't the first one
					rowObject.click(rowHandler);
					
					// do any row selection
					rowSelect(data, rowObject, rowIndex);
					
					
		        } // row loop
		        
		        // if there is a row the current index
		        if (rows[rowIndex]) {
		        	// create a timer to load next batch of rows
		        	var timeoutId = setTimeout(function() { addRowsSimple(grid, rows, rowIndex); });
		        	// retain this timer
		        	_gridLoaders[id].timeouts.push(timeoutId);
		        } else {
		        	// update that we have finished loading
		        	_gridLoaders[id].loading = false;
		        	// apply any after loaded code
					afterLoaded();
		        	// run any loaded handler
                    if (window["Event_gridLoaded_" + id]) window["Event_gridLoaded_" + id](ev);
                }
                
			}

			// add the first set of rows on the main thread
			addRowsSimple(grid.get(0), data.rows, 0);
			
		} // got details and columns and data fields
								
	} // got data
	
	// if we have multiSelect
	if (details.multiSelect) {
		// fixed header clones the header and the checkbox in it so we need to put the header checkbox listener back
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			$("#" + id).find("input.gridMultiSelectHeader").click(function(ev){
				// get the header value
				var select = $(this).prop("checked");
				// update rowSelect accordingly
				if (select) {
					// put rowSelect class on all rows expect for the top one, as it's the header
					grid.find("tr:not(:first-child)").addClass("rowSelect");
				} else {
					grid.find("tr").removeClass("rowSelect");
				}
				// update row checkboxes
				grid.find("input.gridMultiSelect").prop("checked",select);
			});
		}
		// listen for rows checkbox - needs to be click to beat the listener on the row, and use id in case of fixed header
		$(grid).find("input.gridMultiSelect").click(function(ev){
			// get the input
			var i = $(this);
			// get the value
			var select = i.prop("checked");
			// add or remove class accordingly
			if (select) {
				i.closest("tr").addClass("rowSelect");
			} else {
				i.closest("tr").removeClass("rowSelect");
			}
			// check whether any rows without rowSelect, if not uncheck header checkboxs (includes if fixed header)
			if (grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").not(".rowSelect").length > 0) $("#" + id).find("input.gridMultiSelectHeader").prop("checked",false);
		});
	}
	
} else {

	// update data to null
	data = null;
	
}

// save any datastore data
if (details && details.dataStorageType) saveGridDataStoreData(id, details, data);
			]]>
	    </setDataJavaScript>

		<events>
			<event>
				<type>click</type>
				<name>Row click</name>
				<filterFunction>
<![CDATA[
var target = $(ev.target);
/* don't fire if any ancestor is disabled, and the target was within the grid */
if (target.closest("table.grid")[0] && target.closest("[disabled]")[0]) return true;
/* don't fire if the target is the top row or tbody, but allow the multi select */
if ((target.closest("tr").index() == 0 || target.is("tbody")) && !target.is("input.gridMultiSelectHeader")) return true;
/* don't fire if the target is the cell around the multiselect */
if (target.is("td:first-child") && target.children("input.gridMultiSelect")[0]) return true;
]]>	                
	            </filterFunction>
			</event>
			<event>
				<type>gridLoaded</type>
				<name>Loaded</name>
			</event>
		</events>

		<styles>
			<style>
				<name>Grid</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + ", #" + this.id + "header";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Title row</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child, #" + this.id + "header tr:first-child";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Title cells</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child td, #" + this.id + "header tr:first-child td";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row cells</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:not(:first-child) td";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row style 1</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle1";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row style 2</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle2";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row hover</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:hover:not(:first-child)";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row select</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowSelect";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
		</styles>

		<initJavaScript>
	        <![CDATA[
// get the grid
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();     
// check there are details	        
if (details) {

	// if this is a fixed header
	if (details.scrollV && details.fixedHeader) {
	
		// listen for a window resize - sent after grid population and when some controls are made visible
		$(window).on('resize', function(){

			// only if grid is visible and a scroll body has been set up for it
			if (grid.is(":visible") && grid.parent().is("div.gridScrollBody")) {
				// get the header table
				var headerTable =  $("#" + id).find("table").first();			
				// get the header hight
				var headerHeight = headerTable.find("tr:first-child").height();
				// set height of the header table wrapper
				headerTable.parent().css({"height":headerHeight});
				// shift the second table up behind the fixed header
				grid.css("margin-top",-headerHeight);
			}

		});
	
	}
	// if this is multiSelect, set up the header checkbox listener, global as it's shared by the no column dynamic header
	if (details.multiSelect) setGridHeaderMultiSelect(id, grid);
	// if there is a data store
	if (details.dataStorageType) {
		var data = getGridDataStoreData(id, details);
		if (data) setData_grid($.Event('gridinit'), id, null, details, data);
		$("#" + id).click( function(ev) {
			// get the data
			var data = getGridDataStoreData(id, details);
			// if there was some
			if (data) {
				// if multiSelect
				if (details.multiSelect) {
					// get multi selected rows
					data.selectedRowNumber = getGridMultiSelectedRowNumber(id, ev, details);
				} else {
					// get a single selected row
					data.selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
				}
				// save
				saveGridDataStoreData(id, details, data);
			}
		});
	} // datastorage type check
	
	// get the rapid form - it will always have an id and a POST method. Forms in the page from the theme typically don't have the id. If grid data is not being retained in Rapid forms, it may be that duplicate controls are being added to other forms from the theme
	var form = $("form[id][method=POST]");
	// if there was one and Rapid forms has set a _formId, so as not to be included in the downloadCSV form
	if (form[0] && window._formId !== undefined) {
		// add a hidden form input for the grid
		form.append("<input id='" + id + "data' name='" + id + "' type='hidden'/>");
		// listen for form submit and use getData_grid(ev, id, null, details)
		form.submit(function(ev){
			// get grid data and stringify with JSON.stringify
			var jsonData = JSON.stringify(getData_grid(ev, id, null, details));
			// put into our data input which has the name of the control so should be included in the form post
			$("#" + id + "data").val(jsonData);
		});
		
	}
	
} 
	        ]]>	        
	    </initJavaScript>

		<runtimeProperties>
		
			<runtimeProperty>
				<type>rowCount</type>
				<name>Row count</name>				
				<getPropertyFunction>
			        <![CDATA[
// check if the grid is loading			        
if (_gridLoaders[id] && _gridLoaders[id].loading) {
	// if loading send the retained row count
	return _gridLoaders[id].rows;
} else {
	// not loading so check details and storage
	if (details && details.dataStorageType) {
		// there is storage so use that
		var gridData = getGridDataStoreData(id, details);
		if (gridData && gridData.rows) {
			return gridData.rows.length;
		} else {
			return 0;
		}
	} else {
		// get the grid
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// return number of rows
		return grid.find("tr").length - 1;
	}
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>
			</runtimeProperty>

			<runtimeProperty>
				<type>selectedRowData</type>
				<name>Selected row data</name>
				<getPropertyFunction>
			        <![CDATA[
var data = null;
var columns = details.columns || details.dynamicColumns || [];
if (details.dataStorageType) {
	data = getGridDataStoreData(id, details);
	if (data && data.fields && data.rows) {
		var grid = $("#" + id);
		if (!grid.is("table")) grid = grid.find("table").last();
		if (grid[0]) {
			var rowNumber = null;
			if (details.multiSelect) {
				rowNumber = getGridMultiSelectedRowNumber(id, ev, details);
			} else {
				rowNumber = getGridSelectedRowNumber(id, ev, details);
			}
			if (data && rowNumber != data.selectedRowNumber) {
				data.selectedRowNumber = rowNumber;
				saveGridDataStoreData(id, details, data);
			}
		}
		rows = [];
		if (data && data.selectedRowNumber) {
			if (details.multiSelect && $.isArray(data.selectedRowNumber)) {
				for (var i in data.selectedRowNumber) {
					rows.push(data.rows[data.selectedRowNumber[i] - 1]);
				}
			} else {
				if (data.selectedRowNumber > -1) rows.push(data.rows[data.selectedRowNumber - 1]);
			}		
		}
		data.rows = rows;
	}
} else {
	if (details.multiSelect) {
		var rows = getGridMutiSelectedRows(id, ev);
		if (rows && rows.length > 0) {
			data = {fields:[],rows:[]};
			for (var i = 0; i < rows.length; i++) {
				// get a jQuery wrapper for the row element
				var row = $(rows[i]);
				// prepare a data row
				var dataRow = [];
				// loop the columns
				for (var j = 0; j < columns.length; j++) {
					// add fields once only
					if (i == 0) data.fields.push(columns[j].field);
					// get cell html  - one over because of the checkbox
					// unescape
					var value = getGridUnescapedValue(row.children(":nth(" + (j + 1) + ")").html());
										
					// add unescaped cell html to datarow
					dataRow.push(value);
				}
				// add datarow to row
				data.rows.push(dataRow);
			}
		}
	} else {
		var row = getGridSelectedRow(id, ev);
		if (row[0]) {
			data = {fields:[],rows:[[]]};
			for (var i in columns) {
				data.fields.push(columns[i].field);
				// get cell html
					// unescape
				var value = getGridUnescapedValue(row.children(":nth(" + i + ")").html());
				// add unescaped cell html to datarow
				data.rows[0].push(value);
			}
		}
	}
}
// if we were provided with a field to drill into the row data
if (field && data && data.fields && data.rows && data.rows.length > 0) {
	// assume we can't find the field
	var fieldIndex = -1;
	// loop the fields
	for (var i in data.fields) {
		// if there is a field at this position and it case-insentively matches what we're looking for
		if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
			// remember we found it
			fieldIndex = i;
			// we're done
			break;
		}
	}
	// if we found it
	if (fieldIndex > -1) {
		// check multiSelect
		if (details.multiSelect) {
			// create complex data object if so
			var multiRowData = {fields:[field],rows:[]};
			// loop rows - non multi select will have only 1
			for (var i in data.rows) {				
				// get the value
				var value = getGridUnescapedValue(data.rows[i][fieldIndex]);
				// add an empty row array
				multiRowData.rows.push([]);
				// put the value in the row array
				multiRowData.rows[i].push(value);
			}
			// set the data we're returning to what we just made
			data = multiRowData;
		} else {
			// get the value from the first row
			data = getGridUnescapedValue(data.rows[0][fieldIndex]);
		}
	} else {
		// could not find field
		data = null;
	}
}
return data;
			        ]]>      
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
// make a data object
data = makeDataObject(data, field);
// assume no grid data
var gridData = null;
// get the grid select row number which priorities grid in page then data
var rowNumber = getGridSelectedRowNumber(id, ev, details);
// get the grid object
var grid = $("#" + id);
// if we had one in the page
if (grid[0]) {
	// promote to last grid in the case of fixed headers
	if (!grid.is("table")) grid = grid.find("table").last();
	// get data from the page
	gridData = getData_grid(ev, id, null, details);
	// set the row number
	gridData.selectedRowNumber = rowNumber;
	// save the grid data store data (if applicable)
	saveGridDataStoreData(id, details, gridData);
} else {
	// grid not in page so go straight for data store
	gridData = getGridDataStoreData(id, details);	
}
// check we have a selected row
if (gridData && gridData.selectedRowNumber && gridData.selectedRowNumber > 0) {
	// replace or remove selected row	
	if (data && data.fields && data.rows && data.rows.length > 0) {
		// get the gridData fields
		var gridDataFields = gridData.fields;
		// check there are some
		if (gridDataFields) {
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// make sure there was one
				if (field) {
					// assume it wasn't found in the grid's list of fields	
					var foundField = false;							
					// loop the grid's fields
					for (var j in gridData.fields) {
						// if there's a match					
						if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
							// store it's position
							fieldMap[field] = j;
							foundField = true;
							break;
						}
					}
					// if the field wasn't found in the grid
					if (!foundField) {
						// add it to the grid's fields
						gridData.fields.push(field);
						gridData.rows.forEach(function(row) {
							row.push(null);
						});
						// retain the position
						fieldMap[field] = gridData.fields.length - 1;
					}
				}
			}			
			// loop the incoming fields one more time
			for (var i in data.fields) {
				// add an entry at this position if we need one
				if (gridData.rows[gridData.selectedRowNumber - 1].length < data.fields.length) gridData.rows[gridData.selectedRowNumber - 1].push(null);
				// update the selected row field from the map
				gridData.rows[gridData.selectedRowNumber - 1][fieldMap[data.fields[i]]] = data.rows[0][i];
			}			
		} else {
			// take them from the incoming data object
			gridData.fields = data.fields;
			// put top row of what we were passed into selected row
			gridData.rows[gridData.selectedRowNumber - 1] = data.rows[0];
		}		
	} else {
		// remove the selected row 
		gridData.rows.splice(gridData.selectedRowNumber - 1, 1);
		// remove the validation entry if present
		if (gridData.rowValidation) gridData.rowValidation.splice(gridData.selectedRowNumber - 1, 1); 
		// remove the selection
		gridData.selectedRowNumber = null;
	}
	// if there is a datastore to save the data to
	if (details && details.dataStorageType) {
		// if the grid is visible in the page
		if ($("#" + id)[0]) {
	  		// update the grid with the gridData (which will save as well)
	  		setData_grid(ev, id, field, details, gridData, changeEvents);
	  	} else {
	  		// just save the grid
	  		saveGridDataStoreData(id, details, gridData);
	  	}
	} else {
		// update the grid with the gridData (which will save as well)
	  	setData_grid(ev, id, field, details, gridData, changeEvents);
	}
} else {
	// append if no selected row
	if (data) {
		// if no grid data make an empty one so appending will work later
		if (!gridData) gridData = {};
		// create a rows array if not present
		if (!gridData.rows) gridData.rows = [];
		// look for existing fields
		if (gridData.fields) {
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// make sure there was one
				if (field) {
					// assume it wasn't found in the grid's list of fields	
					var foundField = false;							
					// loop the grid's fields
					for (var j in gridData.fields) {
						// if there's a match					
						if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
							// store it's position
							fieldMap[field] = j;
							foundField = true;
							break;
						}
					}
					// if the field wasn't found in the grid
					if (!foundField) {
						// add it to the grid's fields
						gridData.fields.push(field);
						gridData.rows.forEach(function(row) {
							row.push(null);
						});
						// retain the position
						fieldMap[field] = gridData.fields.length - 1;
					}
				}
			}
			
			// make a row
			var row = [];
			// add the cells
			while (row.length < gridData.fields.length) row.push(null);
			// loop the data fields and use the map to get the correct position
			for (var i in data.fields) {
				// get the field
				var field = data.fields[i];
				// get the position
				var pos = fieldMap[field];
				// add it to the correct place in the row
				row[pos] = data.rows[0][i];
			}
			// add the row to the gridData
			gridData.rows.push(row);
		
		} else {
			
			// assume the incoming fields		
			gridData.fields = data.fields;
			// add the top row of what we were given
			gridData.rows.push(data.rows[0]);
		
		}
		
		// set the selected row number
		gridData.selectedRowNumber = gridData.rows.length;
		// save the grid
		saveGridDataStoreData(id, details, gridData);
		// if the grid is visible, refresh it
		if (grid[0]) setData_grid(ev, id, null, details, gridData, changeEvents);
	}	
}	   	            
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>

			<runtimeProperty>
				<type>selectedRowNumber</type>
				<name>Selected row number</name>
				<advanced>true</advanced>
				<getPropertyFunction>
			        <![CDATA[
// check if the grid is loading			        
if (_gridLoaders[id] && _gridLoaders[id].loading) {
	// if loading send the retained selected row number
	return _gridLoaders[id].selectedRowNumber;
} else {
	// not loading so check details and storage
	if (details && details.dataStorageType) {
		// there is storage so use that
		var gridData = getGridDataStoreData(id, details);
		if (gridData && gridData.selectedRowNumber) {
			return gridData.selectedRowNumber;
		} else {
			return null;
		}
	} else {
		// no storage so use the grid
		return getGridSelectedRowNumber(id, ev, details);
	}
} 
			        ]]>	  	   	            
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {fields:[],rows:[]};
data = makeDataObject(data, field);
var selectedRowNumber = null;
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
if (grid) grid.find("tr.rowSelect").removeClass("rowSelect");
if (data) {
	data.rows.map(function(row) {
		if (grid) grid.find("tr:eq(" + row[0] + ")").each(function(i, row) {
			$(row).addClass("rowSelect");
			$(row).find(".gridMultiSelect").prop('checked', true);
		});
		
	});
}
gridData.selectedRowNumber = selectedRowNumber;	
saveGridDataStoreData(id, details, gridData);
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>
			
			<runtimeProperty>
				<type>selectedRowValidation</type>
				<name>Selected row validation</name>
				<advanced>true</advanced>
				<getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rowValidation && gridData.selectedRowNumber) {
		return gridData.rowValidation[gridData.selectedRowNumber - 1];
	} 
} else {
	return getGridSelectedRowNumber(id, ev, details);
}
return null;
			        ]]>	  	   	            
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
	   	            
var data = makeDataObject(data, field);
var selectedRowNumber = null;

// look for the grid on this page
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
// if it's present
if (grid[0]) {
	// get the selected row number
	selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
	// check the incoming data for a positive
	if (data[0][0]) {
		// remove validation class from row if true
		grid.find("tr.rowSelect").removeClass("validation");
	} else {
		// add validation class to row if false
		grid.find("tr.rowSelect").addClass("validation");
	}
}
	            	   	            
if (details && details.dataStorageType) {
	// get the grid data
	gridData = getGridDataStoreData(id, details);
	// make an object if there isn't one
	if (!gridData) gridData = {};
	// if we got a row number from the grid put it into the grid now
	if (selectedRowNumber) gridData.selectedRowNumber = selectedRowNumber;
	// if there are rows and one is selected
	if (gridData.rows && gridData.selectedRowNumber) {
		// add a rowValidation collection if there isn't one
		if (!gridData.rowValidation) gridData.rowValidation = [];
		// ensure the rowValidation collection is the same size as the row collection
		while (gridData.rows.length > gridData.rowValidation) gridData.rowValidation.push(true);
		// set the validation
		gridData.rowValidation[gridData.selectedRowNumber - 1] = data.rows[0][0];
		// save the grid
		saveGridDataStoreData(id, details, gridData);
	}
} 
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>

		</runtimeProperties>

		<designLinkJQuery>
	        <![CDATA[
.filter( function() {
	var link = $(this);
	var id = link.attr("data-id");
	var details = window[id + "details"];
	if (details && details.dataStorageType) {
		return true;
	} else {
		link.hide();
	}
}).click( function(ev) {
	showDesignData($(this));
});	        	        
	        ]]>
	    </designLinkJQuery>

	</control>
</controls>