<?xml version="1.0" encoding="UTF-8" ?>
<controls xmlVersion="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../schemas/control.xsd">

<!-- 

Copyright (C) 2018 - Gareth Edwards / Rapid Information Systems

gareth.edwards@rapid-is.co.uk


This file is part of the Rapid Application Platform

Rapid is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. The terms require you to include
the original copyright, and the license notice in all redistributions.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
in a file named "COPYING".  If not, see <http://www.gnu.org/licenses/>.

 -->
 
	<control>
	
	    <type>grid</type>
	    <name>Grid</name>
	    <image>images/grid.svg</image>
	    <helpHtml>A structure for the layout of controls according to rows and columns.</helpHtml>
	    
	    <addToNewApplications>true</addToNewApplications>
	          
	    <canUserAdd>true</canUserAdd>
	    <canUserMove>true</canUserMove>
	    <canUserAddPeers>true</canUserAddPeers>
	    
	    <properties>
	        
	        <property>
	            <key>name</key>
	            <name>Name</name>
	            <changeValueJavaScript>text</changeValueJavaScript>
	            <helpHtml>Name that can be given to the control. Names are used to help identify controls uniquely.</helpHtml>
	        </property>
	        
	        <property>
	            <key>label</key>
	            <name>Form summary label</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>formText</changeValueJavaScript>
	            <helpHtml>Summary label to appear at the end of the form. Leave blank to have the control and its value hidden.</helpHtml>
	        </property>
	                    
	        <property>
	            <key>columnHeadings</key>
	            <name>Column headings</name>
	            <setConstructValueFunction>return true;</setConstructValueFunction>
	            <changeValueJavaScript>checkbox</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Sets whether the grid will use headings or not.</helpHtml>
	        </property>
	        
	        <property>
	            <key>columns</key>
	            <name>Columns</name>
	            <setConstructValueFunction>return [];</setConstructValueFunction>
	            <changeValueJavaScript>gridColumns</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Sets the different columns to be used by the grid. Multiple can be set or removed here and each can be customised.</helpHtml>
	        </property>
	        
	        <property>
	            <key>multiSelect</key>
	            <name>Multi-select?</name>
	            <setConstructValueFunction>return false;</setConstructValueFunction>
	            <changeValueJavaScript>checkbox</changeValueJavaScript>
	            <refreshHtml>true</refreshHtml>
	            <helpHtml>Whether to show a first column of checkboxes to allow multiple rows in the grid to be selected.</helpHtml>
	        </property>
	        
	        <property>
	            <key>dataStorageType</key>
	            <name>Data store type</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","None"],["L","Local storage"],["S","Session storage"],["P","Page storage"]];
					]]>
	            </getValuesFunction>
	            <helpHtml>Sets the method of data storage. Page storage is for as long as the page is open, session is for as long as the tab/window is open and local is for files to be stored locally on devices.</helpHtml>
	        </property>
	        
	        <property>
	            <key>scrollH</key>
	            <name>Scroll horizontal</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
	            <refreshHtml>true</refreshHtml>
	            <refreshProperties>true</refreshProperties>
	            <helpHtml>Sets the horizontal scrollbar.</helpHtml>
	        </property> 
	        
	        <property>
	            <key>scrollWidth</key>
	            <name>Width</name>
	            <changeValueJavaScript>gridScrollWidth</changeValueJavaScript>
	             <refreshHtml>true</refreshHtml>
	        </property>
	        
	        <property>
	            <key>scrollV</key>
	            <name>Scroll vertical</name>
	            <setConstructValueFunction>return "";</setConstructValueFunction>
	            <changeValueJavaScript>select</changeValueJavaScript>
	            <getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
	            <refreshHtml>true</refreshHtml>
	            <refreshProperties>true</refreshProperties>
	            <helpHtml>Sets the vertical scrollbar.</helpHtml>
	        </property>
	        
	        <property>
	            <key>scrollHeight</key>
	            <name>Height</name>
	            <changeValueJavaScript>gridScrollHeight</changeValueJavaScript>	         
	             <refreshHtml>true</refreshHtml>   
	        </property>	
	        
	        <property>
	            <key>fixedHeader</key>
	            <name>Fixed header</name>
	            <changeValueJavaScript>gridScrollFixedHeader</changeValueJavaScript>	           
	             <refreshHtml>true</refreshHtml> 
	        </property>	
	         
	    </properties>
	    
	    <resources>
	        
	        <resource>	            
	            <type>cssFile</type>
	            <contents>styles/fonts/fontawesome/css/font-awesome.css</contents>
	        </resource>
	        
	        <!-- Some browsers choose the tff instead of the woff so both are included -->
	        <resource>	            
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.woff</contents>
	        </resource>
	        
	        <resource>
	            <type>file</type>
	            <contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.ttf</contents>
	        </resource>
	        
	        <resource>
	            <type>css</type>
	            <contents>
	                <![CDATA[	                
table.grid {
	border-collapse:collapse;
}          

table.grid td {
	border: 0;
}     

table.grid span.sort {
	font-family: FontAwesome;
	margin-left: 5px;
}

div.gridScroll {
	display: inline-block;
}

div.gridScroll table {
	width: 100%;
}

div.gridScrollHeader {
	overflow-y: hidden;
}

div.gridScrollHeader table {
	width: calc(100% - 16px) !important;	
}

div.gridScrollHeader table.grid tr:not(:first-child) {
	visibility: hidden;
}

div.gridScrollBody table.grid tr:first-child {
	visibility: hidden;
}
	                ]]>
				</contents>
	        </resource>
	        
	        <resource>
	            <type>javascript</type>
	            <contents>
	                <![CDATA[
	                
function getGridDataStoreData(id, details) {
	data = null;
	dataString = null;
	switch (details.dataStorageType) {
		case "L" :
			dataString = localStorage[_appId + id];
		break;
		case "S" :
			dataString = sessionStorage[_appId + id];
		break;
		case "P" :
			dataString = window[id + "datastore"];			
		break;
	}
	if (dataString) {
		data = JSON.parse(dataString);
		if (data) {
			if (!data.fields) data.fields = [];
			if (!data.rows) data.rows = [];
		}
	}
	return data;
}

function saveGridDataStoreData(id, details, data) {
	switch (details.dataStorageType) {
		case "L" :
			localStorage[_appId + id] = JSON.stringify(data);
		break;
		case "S" :		
			sessionStorage[_appId + id] = JSON.stringify(data);
		break;
		case "P" :
			window[id + "datastore"] = JSON.stringify(data);
		break;
	}
}	

function sortGridByColumn(ev, id, details, column, asc) {

	// check we have details and this column
	if (details && details.columns && details.columns[column]) {

		// get the grid data
		var data = getData_grid(ev, id, null, details);
			
		// get the field
		var field = details.columns[column].field;
		
		// assume data and details columns are the same
		var dataColumn = column;
		
		// check the column matches the field
		if (data.fields[column] != field) {
			// didn't match so find what it should be
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					dataColumn = i;
					break;
				}
			}	
		}
	
		// check there is data for the column
		if (data && data.rows && data.fields[dataColumn]) {
		
			// an array for all values in this column
			var sortedValues = [];
			// populate the array for each row with an object with the original index and value
			for (var i in data.rows) sortedValues.push( {index:i, value:data.rows[i][dataColumn]} );
			// determin the sort type
			switch (details.columns[column].sort) {
				// for n, turn both values into numbers and use that
				case "n" : sortedValues.sort( function(i1, i2) {
					var v1 = i1.value;
					if (v1) v1 = parseFloat(v1.replace(",",""));
					var v2 = i2.value;
					if (v2) v2 = parseFloat(v2.replace(",",""));
					return v1 - v2; 
				});			
				break;
				// d1 is uk date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make dates
						var d1 = new Date(d1Parts[2], d1Parts[1]-1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], d2Parts[1]-1, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d2 is uk month-word date format
				case "d2": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// get the months
						var months = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"];
						for (m1 in months) if (d1Parts[1].toLowerCase().substr(0,3) == months[m1]) break;
						for (m2 in months) if (d2Parts[1].toLowerCase().substr(0,3) == months[m2]) break;
						// make the dates
						var d1 = new Date(d1Parts[2], m1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], m2, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d3 is us date format
				case "d3": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make the dates
						var d1 = new Date(d1Parts[2], d1Parts[0]-1, d1Parts[1]);
						var d2 = new Date(d2Parts[2], d2Parts[0]-1, d2Parts[1]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d4 is xml date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// make the dates
						var d1 = new Date(d1Parts[0], d1Parts[1]-1, d1Parts[2]);
						var d2 = new Date(d2Parts[0], d2Parts[1]-1, d2Parts[2]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// for c, make a new function from the sortFunction property and use that
				case "c":
					var f = new Function("item1","item2",details.columns[column].sortFunction);
					sortedValues.sort(f);				
				break;
				default : sortedValues.sort( function(i1, i2) {				
					// easy one's first
					if (i1.value == null) {				
						return 1;
					} else if (i2.value == null) {
						return -1;
					} else {
						// assume the values match
						var s = 0;
						// get both values in lower case
						v1 = i1.value.toLowerCase();
						v2 = i2.value.toLowerCase();
						// only if the two are different
						if (v1 != v2) {			
								// get the shortest length
								var l = Math.min(v1.length, v2.length);
								// loop the shortest length
								for (var i = 0; i < l; i++) {
									// check the different in ascii values
									if (v1.charCodeAt(i) > v2.charCodeAt(i)) {
										s = 1;
										break;
									} else if (v1.charCodeAt(i) < v2.charCodeAt(i)) {
										s = -1;
										break;
									}					
								}
								// if s is still zero use the length of the strings
								if (s == 0) s = v1.length - v2.length;			
						} // same check
						return s
					} // null checks					
				}); 
			}
					
			// create a new rows array
			var rows = [];
			// if asc
			if (asc) {
				// loop the returned sorted column values and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[i].index]);
			} else {
				// loop the returned sorted column values in reverse  and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[sortedValues.length - i - 1].index]);
			}
			// replace the data rows with the placed rows
			data.rows = rows;
			// set the sorted data
			setData_grid(ev, id, null, details, data);
		}
	}
} 

// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = -1;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row of the correct grid
	if (row[0] && row.closest("#" + id)[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
		// get the position of relevant row
		index = rows.index(row);
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// index is the row with the selected style within the grid
		index = grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(grid.find("tr.rowSelect"));			
	}
	if (index > -1) index ++;
	return index;
}

// gets the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRow(id, ev) {
	// assume we're not going to find it
	var row = null;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row of the correct grid
	if (row[0] && row.closest("#" + id)[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// row is .rowSelect
		row = grid.find("tr.rowSelect").not("[data-ignore]");			
	}
	return row;
}


// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMultiSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = null;
	// get the table using the id
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// get any rowSelect rows
	var rows = grid.find("tr.rowSelect").not("[data-ignore]");
	// if we got some
	if (rows.length > 0) {
		// make index an array
		index = [];
		// for each row
		rows.each( function(i){
			// add to index
			index.push(grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(this) + 1);
		});
	}
	return index;
}

// gets the selected rows, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMutiSelectedRows(id, ev) {
	// assume we're not going to find any
	var rows = null;
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// rows have .rowSelect and not data-ignore
	rows = grid.find("tr.rowSelect").not("[data-ignore]");			
	// return
	return rows;
}
           	
	                ]]>
	            </contents>
	        </resource>
	    </resources>
	    
	    <getHtmlFunction>
	        <![CDATA[ 
var headerHtml = "<tr" + (this.columnHeadings ? "" : " style='display:none;'") + ">";
var rowHtml = "<tr><td>No columns</td></tr>";
if (this.columns.length > 0) {
	var rowHtml = "<tr>";
	if (this.multiSelect) {
		headerHtml += "<td><input type='checkbox' class='gridMultiSelectHeader'/></td>";
		rowHtml += "<td><input type='checkbox' class='gridMultiSelect'/></td>";
	}
	var columnCount = 0;
	for (var i in this.columns) {
		var column = this.columns[i];
		if (column.visible) {
			headerHtml += "<td" + (column.titleStyle ? " style='" + escapeApos(column.titleStyle) + "'" : "") + ">" + column.title;
			if (column.sort) headerHtml += "<span class='sort'>&#xf0dc;</span>";
			headerHtml += "</td>";
			if (i % 2 == 1) {
			 	rowHtml += "<td " + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">123.00</td>"
			} else {
				rowHtml += "<td" + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">Data</td>"
			}
			columnCount ++;
		} else {
			headerHtml += "<td style='display:none;'>" + column.title + "</td>";
			rowHtml += "<td style='display:none;'></td>"
		}
	}
	if (columnCount == 0) {
		headerHtml += "<td>No visible columns</td>"
		rowHtml += "<td>No visible columns</td>";
	}
	headerHtml += "</tr>";
	rowHtml += "</tr>";
} else {
	headerHtml += "<td>No columns</td>"
}
	                
// check for scrolling
if (this.scrollH || this.scrollV) {
	// return a container div with the table inside
	return "<div id='" + this.id + "' style='display:inline-block;" + (this.scrollH ? "overflow-x:" + this.scrollH + ";max-width:" + this.scrollWidth + ";" : "") + "' class='gridScroll" + getStyleClasses(this) + "'><table class='grid'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table></div>";
} else {
	// return a simple table
	return "<table id='" + this.id + "' class='grid" + getStyleClasses(this) + "'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table>";
}
	        ]]>
	    </getHtmlFunction>
 	    
	   <initDesignJavaScript>
	   		<![CDATA[
// upgrade any previous version styles to this version to include the header
if (this.styles && this.styles.length > 0) {
	// get the id
	var id = this.id;
	for (var i =0; i < this.styles.length; i++) {
		// get the style
		var style = this.styles[i];
		// if this is one to upgrade do so
		if (style.appliesTo == "#" + id) this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child td") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child td", rules: style.rules});
	}
}
	   		]]>
	   </initDesignJavaScript>
	   
	    <saveJavaScript>
	        <![CDATA[
// get our object
var table = this.object;
if (!table.is("table")) table = table.find("table").last();
// remove all sample rows, leaving the header row
table.children().last().children(":not(:first)").remove();
// if we have datastorage of type P, turn off canBeUsedFromOtherPages
if (this.dataStorageType == "P") this.canBeUsedFromOtherPages = false;  
	        ]]>
	    </saveJavaScript>
	    
	    <getDetailsFunction>	        
	        <![CDATA[
var details = {type: this.type};
if (this.columns && this.columns.length > 0) {
	details.columns = [];
	for (var i in this.columns) {
		var column = this.columns[i];
		var c = {};
		if (column.visible) c.visible = column.visible;
		if (column.field) c.field = column.field;
		if (column.fieldStyle) c.style = column.fieldStyle;		
		if (column.sort) c.sort = column.sort;
		if (column.sortFunction) c.sortFunction = column.sortFunction;
		if (column.cellFunction) c.cellFunction = column.cellFunction;			
		details.columns.push(c);
	}
} 	        
if (this.styles && this.styles.length > 0) {
	details.rowHover = false;
	details.rowSelect = false;
	for (var i in this.styles) {
		var style = this.styles[i];
		if (style.appliesTo && style.appliesTo.indexOf("rowHover") > 0) details.rowHover = true;
		if (style.appliesTo && style.appliesTo.indexOf("rowSelect") > 0) details.rowSelect = true;
	}
}
// set multiSelect
if (this.multiSelect) details.multiSelect = true;
// check and set data storage
if (this.dataStorageType) {
	this.canBeUsedFromOtherPages = true;
	details.dataStorageType = this.dataStorageType;
} else {
	this.canBeUsedFromOtherPages = false;
}
// if scrollH set header and width
if (this.scrollH) {
	details.scrollH = this.scrollH;
	details.scrollWidth = this.scrollWidth;
}
// if scrollV set scroll, height, and header
if (this.scrollV) {
	details.scrollV = this.scrollV;
	details.scrollHeight = this.scrollHeight;
	details.fixedHeader = this.fixedHeader;
}
return details;
			]]>	        	        
	    </getDetailsFunction>
	    
	    <getDataFunction>
	        <![CDATA[
var data = null;
if (details) {
	// if there is a datastore and the grid is not present in the page    
	if (details.dataStorageType && !$("#" + id)[0]) {
		data = getGridDataStoreData(id, details);
		if (field && data.fields && data.rows && data.rows.length > 0) {
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					data = data.rows[0][i];
					break;
				}
			}
		}
	} else if (details.columns) {
		if (field) {		
			var row = getGridSelectedRow(id, ev);
			if (row[0]) {
				for (var i in details.columns) {
					if (details.columns[i].field && details.columns[i].field.toLowerCase() == field.toLowerCase()) {
						data = row.children(":nth(" + i + ")").html();
						break;
					}
				}
			}	    
			if (data == null && details.dataStorageType) {
				var dataStore = getGridDataStoreData(id, details);
				var rowIndex = getGridSelectedRowNumber(id, ev, details);
				rowIndex --;
				if (rowIndex > -1 && dataStore.rows && dataStore.rows.length > rowIndex) {
					for (var i in dataStore.fields) {
						if (dataStore.fields[i] && dataStore.fields[i].toLowerCase() == field.toLowerCase()) {
							data = dataStore.rows[rowIndex][i];
							break;
						}
					}
				}
			}
		} else {
			var data = {};
			data.fields = [];		
			for (var i in details.columns) {
				var field = details.columns[i].field;
				if (field) data.fields.push(details.columns[i].field);		
			}
			data.rows = [];
			var table = $("#" + id);
			if (!table.is("table")) table = table.find("table").last();
			table.find("tr:not(:first):not([data-ignore])").each(function(i) {
				var row = [];
				$(this).children().each(function(i) {
					if (details.multiSelect) i--;
					if (i >= 0 && details.columns[i].field) row.push($(this).html());
				});
				data.rows.push(row);
			});
			// if there is a data store
			if (details.dataStorageType) {
			    // get the data from the data store
				var dataStore = getGridDataStoreData(id, details);
				// if we got one
				if (dataStore) {
					// make a field map of data from the grid to data from the dataStore
					var fieldMap = {};
					// loop the fields from the control in the page
					for (var i in data.fields) {
						// assume we can't find this field
						var found = false;
						// loop the fields from the dataStore
						for (var j in dataStore.fields) {
							// if this is the field they both have
							if (data.fields[i] && dataStore.fields[j] && data.fields[i].toLowerCase() == dataStore.fields[j].toLowerCase()) {
								fieldMap[i] = j;
								found = true;
								break;
							}							
						}
						// if not found 
						if (!found) {
							//add to dataStore fields
							dataStore.fields.push(data.fields[i]);
							// add to map
							fieldMap[i] = dataStore.fields.length - 1;
						}	
					}
					// loop the rows in the data from the grid
					for (var i in data.rows) {
						// add an empty row to the dataStore rows if there are more in the page
						if (dataStore.rows.length < i - 1) dataStore.rows.push([]);
						// if there are less cells in the rows than it's fields add more
						while (dataStore.rows[i].length < dataStore.fields.length) dataStore.rows[i].push(null);						
						// loop the fieldMap and update dataStore with values from page
						for (j in fieldMap) dataStore.rows[i][fieldMap[j]] = data.rows[i][j];						
					}
					// set data to our merged dataStore
					data = dataStore;	
				}							
			}						
		}	
	}
}
return data;
			]]>
	    </getDataFunction>	   
	    	    	   
	    <setDataJavaScript>
	        <![CDATA[
// get the grid control	        
var control = $("#" + id);
// make sure it's a table
if (!control.is("table")) control = control.find("table").last();
// remove all rows except for the first one
control.find("tr:not(:first-child)").remove();	        
// reset any sort indicators if not being used for sorting
control.find("span.sort").html("&#xf0dc");
// if we have data
if (data !== undefined) {

	data = makeDataObject(data, field);
	if (data && data.rows) {	        		
		if (details && details.columns && data.fields) {
			var columnMap = [];
			for (var i in details.columns) {				
				for (var j in data.fields) {
					var found = false;
					if (details.columns[i].field && data.fields[j]) {
						if (details.columns[i].field.toLowerCase() == data.fields[j].toLowerCase()) found = true;
					} else {
						if (!data.fields[j]) found = true;
					}
					if (found) {
						columnMap.push(j);
						break;
					}
				}
				// added the column to the map
				if (columnMap.length == i) columnMap.push("");
				// if we have cellFunction JavaScript, and it hasn't been turned into a function object yet
				if (details.columns[i].cellFunction && !details.columns[i].f) details.columns[i].f = new Function(["id", "data", "field", "details", "value"],details.columns[i].cellFunction);
			}
			for (var i in data.rows) {
				var row = data.rows[i];
				var rowObject = control.append("<tr class='rowStyle" + (i % 2 + 1) + "'></tr>").find("tr:last");
				// add multiselect
				if (details.multiSelect) rowObject.append("<td><input type='checkbox' class='gridMultiSelect' /></td>");
				// loop colummns
				for (var j in details.columns) {
					var style = "";
					if (!details.columns[j].visible) style += "display:none;";
					if (details.columns[j].style) style += details.columns[j].style;
					if (style) style = " style='" + style + "'";
					// assume the cell has no value
					var value = "";				
					// get the position of this column in the data object
					var mappedCol = columnMap[j];
					// if we can find the column and it has data use it as the value
					if (mappedCol && row[mappedCol] !== null) value = row[columnMap[j]];
					// add the cell with the value and return a reference
					var cellObject = rowObject.append("<td" + style + ">" + value + "</td>").children("td:last");
					// apply any cell function
					if (details.columns[j].f) {
						details.columns[j].f.apply(cellObject,[id, data, field, details, value]);
					}
				}		
				// if there is a rowValidation collection
				if (data.rowValidation && i < data.rowValidation.length) {
					if (!data.rowValidation[i]) rowObject.addClass("validation");
				}		
			}
			// if there is a selected row
			if (data.selectedRowNumber) control.find("tr:nth(" + data.selectedRowNumber + ")").addClass("rowSelect");
		} else {
			for (var i in data.rows) {
				// add a row object with the styling
				var rowObject = control.append("<tr class='rowStyle" + (i % 2 + 1) + "'></tr>").find("tr:last");
				// get the row
				var row = data.rows[i];
				// loop the row cells				
				for (var j in row) {
					// add cell with value to row
					rowObject.append("<td" + style + ">" + row[j] + "</td>");
				}
			}
		} // got details and columns and data fields							
	} // got data
	if (details && details.dataStorageType) saveGridDataStoreData(id, details, data);
		
	// if we vertical scrolling
	if (details && details.scrollV && details.scrollHeight) {
	
		// if we have a fixed header
		if (details.fixedHeader) {
		
			// if we haven't applied it yet
			if (!control.parent().is(".gridScrollBody")) {
		
			    // create and style the wrapper
			    var oTblDiv = $("<div class='gridScrollBody' />");
			    oTblDiv.css({
			    	"max-height": details.scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // wrap it
			    control.wrap(oTblDiv);

			    // save original column widths			    			    
			    control.find('thead tr td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    }); 
			    control.find('tbody tr:eq(0) td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    });                 
			
			    // clone the original table
			    var newTbl = control.clone();
			    // update it's id
			    newTbl.attr("id",id + "header");
			    				
				// set the class on the parent on the new table (this is the control root)
			    newTbl.parent().addClass("gridScroll");	      
				// get the old table parent
			    var parent = control.parent();
				// add the new table
			    parent.parent().prepend(newTbl);			    
			    // move the old table parent after the new table
			    parent.insertAfter(newTbl);
			    // wrap the new table
			    newTbl.wrap("<div class='gridScrollHeader' />")
			    				    			
			    // replace original column widths
			    newTbl.find('thead tr td').each(function(){
			        $(this).width($(this).attr("data-item-original-width"));
			    });     
			    control.width(control.attr('data-item-original-width'));      
			    control.find('tbody tr:eq(0) td').each(function(){
			        $(this).width($(this).attr("data-item-original-width"));
			    });
			    
			    // positioning the header has been moved to the init on window resize
			    
			} // fixed header applied
		    
		} else {
		
			// check not applied already
			if (!control.parent().is(".gridScrollApplied")) {

				// remove the table id
				control.removeAttr("id")
				// create and style the wrapper
			    var oTblDiv = $("<div class='gridScroll' id='" + id + "' />");
			    oTblDiv.css({
			    	"max-height": details.scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // retain that we have applied the scroll
			    oTblDiv.addClass("gridScrollApplied");
			    // wrap it
			    control.wrap(oTblDiv);
			    
			} // v scroll applied check
		
		} // fixed header
				
	} // vertical scrolling
	
	// if have not applied sorts yet
	if (details && !control.parent().is(".gridSortsApplied")) {
	
		// assume no headers
		var headers = null;
		// if there is vertical scrolling
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			// get the visible header cells
			headers = $("#" + id).find("table").first().find("tr:first-child td");
		} else {
			headers = control.find("tr:first-child td");
		}
	
		// loop the columns
		for (var i in details.columns) {
			// if it has a sort (but not a fuxed)
			if (details.columns[i].sort) {
				// assume the index is i
				var index = i;
				// if we have multiselect move the index on one
				if (details.multiSelect) index ++;
				// get the header cell - move one on if we have multiselect
				var cell = $(headers.get(index));
				// change the cursor
				cell.css("cursor","pointer");
				// add a listener
				cell.click( {index:index},function(ev) {
					// get the span
					var span = $(ev.target);
					// drill down if need be
					if (!span.is("span")) span = span.find("span");
					// if ascending or not set (note the unicode escape)
					if (span.html() == "\uf0de") {
						sortGridByColumn(ev, id, details, ev.data.index, false);
						span.html("&#xf0dd;");
					} else {
						sortGridByColumn(ev, id, details, ev.data.index, true);
						span.html("&#xf0de;");
					}
				});
			}
		}
		
		// mark grid as having sorts applied
		control.parent().addClass("gridSortsApplied");
	
	}
	
	// if we have multiSelect
	if (details.multiSelect) {
		// fixed header clones the header and the checkbox in it so we need to put the header checkbox listener back
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			$("#" + id).find("input.gridMultiSelectHeader").click(function(ev){
				// get the header value
				var select = $(this).prop("checked");
				// update rowSelect accordingly
				if (select) {
					// put rowSelect class on all rows expect for the top one, as it's the header
					control.find("tr:not(:first-child)").addClass("rowSelect");
				} else {
					control.find("tr").removeClass("rowSelect");
				}
				// update row checkboxes
				control.find("input.gridMultiSelect").prop("checked",select);
			});
		}
		// listen for rows checkbox - needs to be click to beat the listener on the row, and use id in case of fixed header
		$(control).find("input.gridMultiSelect").click(function(ev){
			// get the input
			var i = $(this);
			// get the value
			var select = i.prop("checked");
			// add or remove class accordingly
			if (select) {
				i.closest("tr").addClass("rowSelect");
			} else {
				i.closest("tr").removeClass("rowSelect");
			}
			// check whether any rows without rowSelect, if not uncheck header checkboxs (includes if fixed header)
			if (control.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").not(".rowSelect").length > 0) $("#" + id).find("input.gridMultiSelectHeader").prop("checked",false);
		});
	}
	 
	// if we click on a row that isn't the first one
	control.children().last().children("tr:not(:first)").click( function(ev) {
		// get the row 
		var row = $(this);
		// if this grid has multiselect thhings are more confusing
		if (details.multiSelect) {
			// get the target
			var target = $(ev.target);
			// if we're here because we clicked the gridMultiSelect checkbox - in this case row selection is done in the input click listener, above, also do nothing is cell around the multiselect clicked
			if (!target.is("input.gridMultiSelect") && !target.children("input.gridMultiSelect")[0]) {
				// remove rowSelect class from all rows in the table
				row.parent().find("tr.rowSelect").removeClass("rowSelect");
				// add rowSelect to this row
				row.addClass("rowSelect");
				// uncheck all inputs
				$("#" + id).find("input.gridMultiSelectHeader, input.gridMultiSelect").prop("checked",false);
			}
		} else {
			// remove rowSelect class from all rows in the table
			row.parent().find("tr.rowSelect").removeClass("rowSelect");
			// add rowSelect to this row
			row.addClass("rowSelect");
		}
	});
	
	// apply the resizing	
	$(window).resize(); 
	
}
			]]>
	    </setDataJavaScript>
	    
	    <events>
	        <event>
	            <type>click</type>
	            <name>Row click</name>
	            <filterFunction>
<![CDATA[
var target = $(ev.target);
// don't fire if the target is the top row or tbody, but allow the multi select
if ((target.closest("tr").index() == 0 || target.is("tbody")) && !target.is("input.gridMultiSelectHeader")) return true;
// don't fire if the target is the cell around the multiselect
if (target.is("td:first-child") && target.children("input.gridMultiSelect")[0]) return true;
]]>	                
	            </filterFunction>
	        </event>
	    </events> 
	    
	    <styles>
	        <style>
	            <name>Grid</name>  
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + ", #" + this.id + "header";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Title row</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child, #" + this.id + "header tr:first-child";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Title cells</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child td, #" + this.id + "header tr:first-child td";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row cells</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:not(:first-child) td";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row style 1</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle1";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row style 2</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle2";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>
	        <style>
	            <name>Row hover</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:hover:not(:first-child)";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>	 
	        <style>
	            <name>Row select</name>
	            <getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowSelect";
	       			 ]]>	                
	            </getAppliesToFunction>
	        </style>       
	    </styles>
	    
	    <initJavaScript>
	        <![CDATA[
// get the control
var control = $("#" + id);
// make sure it's a table
if (!control.is("table")) control = control.find("table").last();     
// check there are details	        
if (details) {

	// if this is a fixed header
	if (details.scrollV && details.fixedHeader) {
	
		// listen for a window resize - sent after grid population and when some controls are made visible
		$(window).on('resize', function(){

			// only if control is visible and a scroll body has been set up for it
			if (control.is(":visible") && control.parent().is("div.gridScrollBody")) {
				// get the header table
				var headerTable =  $("#" + id).find("table").first();			
				// get the header hight
				var headerHeight = headerTable.find("tr:first-child").height();
				// set height of the header table wrapper
				headerTable.parent().css({"height":headerHeight});
				 // shift the second table up behind the fixed header
				control.css("margin-top",-headerHeight);
			}

		});
	
	}
	// if this is multiSelect, set up the header checkbox listener
	if (details.multiSelect) {
		$("#" + id).find("input.gridMultiSelectHeader").change(function(ev) {
			// get the header value
			var select = $(this).prop("checked");
			// update rowSelect accordingly
			if (select) {
				control.find("tr").addClass("rowSelect");
			} else {
				control.find("tr").removeClass("rowSelect");
			}
			// update row checkboxes
			control.find("input.gridMultiSelect").prop("checked",select);
		});
	}
	// if there is a data store
	if (details.dataStorageType) {
		var data = getGridDataStoreData(id, details);
		if (data) setData_grid($.Event('gridinit'), id, null, details, data);
		$("#" + id).click( function(ev) {
			// get the data
			var data = getGridDataStoreData(id, details);
			// if there was some
			if (data) {
				// if multiSelect
				if (details.multiSelect) {
					// get multi selected rows
					data.selectedRowNumber = getGridMultiSelectedRowNumber(id, ev, details);
				} else {
					// get a single selected row
					data.selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
				}
				// save
				saveGridDataStoreData(id, details, data);
			}
		});
	} // datastorage type check
	
	// get any form
	var form = $("form");
	// if there was one
	if (form) {
		// add a hidden form input for the grid
		form.append("<input id='" + id + "data' name='" + id + "' type='hidden'/>");
		// listen for form submit and use getData_grid(ev, id, null, details)
		$("form").submit(function(ev){
			//getData_grid, // stringify with JSON.stringify and put into $("#" + id + "value")
			var jsonData = JSON.stringify(getData_grid(ev, id, null, details));
			$("#" + id + "data").val(jsonData);
		});
		
	}
	
} 
	        ]]>	        
	    </initJavaScript>
	    
	    <runtimeProperties>
	        
	        <runtimeProperty>
	   	        <type>selectedRowData</type>
	   	        <name>Selected row data</name>
	   	        <getPropertyFunction>
			        <![CDATA[
var data = null;
if (details.dataStorageType) {
	data = getGridDataStoreData(id, details);	
	var grid = $("#" + id);
	if (!grid.is("table")) grid = grid.find("table").last();
	if (grid[0]) {
		var rowNumber = null;
		if (details.multiSelect) {
			rowNumber = getGridMultiSelectedRowNumber(id, ev, details);
		} else {
			rowNumber = getGridSelectedRowNumber(id, ev, details);
		}
		if (data && rowNumber != data.selectedRowNumber) {
			data.selectedRowNumber = rowNumber;
			saveGridDataStoreData(id, details, data);
		}
	}
	rows = [];
	if (data && data.selectedRowNumber) {
		if (details.multiSelect && $.isArray(data.selectedRowNumber)) {
			for (var i in data.selectedRowNumber) {
				rows.push(data.rows[data.selectedRowNumber[i] - 1]);
			}
		} else {
			if (data.selectedRowNumber > -1) rows.push(data.rows[data.selectedRowNumber - 1]);
		}		
	}
	data.rows = rows;
} else {
	if (details.multiSelect) {
		var rows = getGridMutiSelectedRows(id, ev);
		if (rows && rows.length > 0) {
			data = {fields:[],rows:[]};
			for (var i = 0; i < rows.length; i++) {
				// get a jQuery wrapper for the row element
				var row = $(rows[i]);
				// prepare a data row
				var dataRow = [];
				// loop the columns
				for (var j = 0; j < details.columns.length; j++) {
					// add fields once only
					if (i == 0) data.fields.push(details.columns[j].field);
					// add cell html to datarow - one over because of the checkbox
					dataRow.push(row.children(":nth(" + (j + 1) + ")").html());
				}
				// add datarow to row
				data.rows.push(dataRow);
			}
		}
	} else {
		var row = getGridSelectedRow(id, ev);
		if (row[0]) {
			data = {fields:[],rows:[[]]};
			for (var i in details.columns) {
				data.fields.push(details.columns[i].field);
				data.rows[0].push(row.children(":nth(" + i + ")").html());
			}
		}
	}
}
// if we were provided with a field to drill into the row data
if (field && data && data.fields && data.rows && data.rows.length > 0) {
	// assume we can't find the field
	var fieldIndex = -1;
	// loop the fields
	for (var i in data.fields) {
		// if there is a field at this position and it case-insentively matches what we're looking for
		if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
			// remember we found it
			fieldIndex = i;
			// we're done
			break;
		}
	}
	// if we found it
	if (fieldIndex > -1) {
		// check multiSelect
		if (details.multiSelect) {
			// create complex data object if so
			var multiRowData = {fields:[field],rows:[]};
			// loop rows - non multi select will have only 1
			for (var i in data.rows) {				
				// get the value
				var value = data.rows[i][fieldIndex];
				// add an empty row array
				multiRowData.rows.push([]);
				// put the value in the row array
				multiRowData.rows[i].push(value);
			}
			// set the data we're returning to what we just made
			data = multiRowData;
		} else {
			// get the value from the first row
			data = data.rows[0][fieldIndex];
		}
	} else {
		// could not find field
		data = null;
	}
}
return data;
			        ]]>      
	   	        </getPropertyFunction>
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {};
var grid = $("#" + id);
if (!grid.is("table")) grid = grid.find("table").last();
if (grid[0]) {
		var rowNumber = getGridSelectedRowNumber(id, ev, details);
		if (rowNumber != gridData.selectedRowNumber) {
			gridData.selectedRowNumber = rowNumber;
			saveGridDataStoreData(id, details, gridData);
		}
	}
data = makeDataObject(data, field);
if (gridData.selectedRowNumber && gridData.selectedRowNumber > 0) {
	// replace or remove selected row	
	if (data && data.fields && data.rows && data.rows.length > 0) {
		// get the gridData fields
		var gridDataFields = gridData.fields;
		// check there are some
		if (gridDataFields) {
			
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}			
			// loop the incoming fields one more time
			for (var i in data.fields) {
				// add an entry at this position if we need one
				if (gridData.rows[gridData.selectedRowNumber - 1].length < data.fields.length) gridData.rows[gridData.selectedRowNumber - 1].push(null);
				// update the selected row field from the map
				gridData.rows[gridData.selectedRowNumber - 1][fieldMap[data.fields[i]]] = data.rows[0][i];
			}			
		} else {
			// take them from the incoming data object
			gridData.fields = data.fields;
			// put top row of what we were passed into selected row
			gridData.rows[gridData.selectedRowNumber - 1] = data.rows[0];
		}		
	} else {
		// remove the selected row 
		gridData.rows.splice(gridData.selectedRowNumber - 1, 1);
		// remove the validation entry if present
		if (gridData.rowValidation) gridData.rowValidation.splice(gridData.selectedRowNumber - 1, 1); 
		// remove the selection
		gridData.selectedRowNumber = null;
	}
	// if there is a datastore to save the data to
	if (details && details.dataStorageType) {
		// if the grid is visible in the page
		if ($("#" + id)[0]) {
	  		// update the grid with the gridData (which will save as well)
	  		setData_grid(ev, id, field, details, gridData, changeEvents);
	  	} else {
	  		// save the grid
	  		saveGridDataStoreData(id, details, gridData);
	  	}
	}
} else {
	// append if no selected row
	if (data) {
		// create a rows array if not present
		if (!gridData.rows) gridData.rows = [];
		// look for existing fields
		if (gridData.fields) {
		
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}
			
			// make a row
			var row = [];
			// add the cells
			while (row.length < gridData.fields.length) row.push(null);
			// loop the data fields and use the map to get the correct position
			for (var i in data.fields) {
				// get the field
				var field = data.fields[i];
				// get the position
				var pos = fieldMap[field];
				// add it to the correct place in the row
				row[pos] = data.rows[0][i];
			}
			// add the row to the gridData
			gridData.rows.push(row);
		
		} else {
			
			// assume the incoming fields		
			gridData.fields = data.fields;
			// add the top row of what we were given
			gridData.rows.push(data.rows[0]);
		
		}
		
		// set the selected row number
		gridData.selectedRowNumber = gridData.rows.length;
		// save the grid
		saveGridDataStoreData(id, details, gridData);
		// if the grid is visible, refresh it
		if (grid[0]) setData_grid(ev, id, null, details, gridData, changeEvents);
	}	
}	   	            
	   	            ]]>
	   	        </setPropertyJavaScript>	        
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>selectedRowValidation</type>
	   	        <name>Selected row validation</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rowValidation && gridData.selectedRowNumber) {
			return gridData.rowValidation[gridData.selectedRowNumber - 1];
	} 
} else {
	return getGridSelectedRowNumber(id, ev, details);
}
return null;
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
	   	            
var data = makeDataObject(data, field);
var selectedRowNumber = null;

// look for the grid on this page
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
// if it's present
if (grid[0]) {
	// get the selected row number
	selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
	// check the incoming data for a positive
	if (data[0][0]) {
		// remove validation class from row if true
		grid.find("tr.rowSelect").removeClass("validation");
	} else {
		// add validation class to row if false
		grid.find("tr.rowSelect").addClass("validation");
	}
}
	            	   	            
if (details && details.dataStorageType) {
	// get the grid data
	gridData = getGridDataStoreData(id, details);
	// make an object if there isn't one
	if (!gridData) gridData = {};
	// if we got a row number from the grid put it into the grid now
	if (selectedRowNumber) gridData.selectedRowNumber = selectedRowNumber;
	// if there are rows and one is selected
	if (gridData.rows && gridData.selectedRowNumber) {
		// add a rowValidation collection if there isn't one
		if (!gridData.rowValidation) gridData.rowValidation = [];
		// ensure the rowValidation collection is the same size as the row collection
		while (gridData.rows.length > gridData.rowValidation) gridData.rowValidation.push(true);
		// set the validation
		gridData.rowValidation[gridData.selectedRowNumber - 1] = data.rows[0][0];
		// save the grid
		saveGridDataStoreData(id, details, gridData);
	}
} 
	   	            ]]>
	   	        </setPropertyJavaScript>		   	                
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>selectedRowNumber</type>
	   	        <name>Selected row number</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.selectedRowNumber) {
		return gridData.selectedRowNumber;
	} else {
		return null;
	}
} else {
	return getGridSelectedRowNumber(id, ev, details);
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	
	   	        <setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {fields:[],rows:[]};
data = makeDataObject(data, field);
var selectedRowNumber = null;
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
if (grid) grid.find("tr.rowSelect").removeClass("rowSelect");
if (data) {
	selectedRowNumber = data.rows[0][0];
	if (grid) grid.find("tr:eq(" + selectedRowNumber + ")").addClass("rowSelect");
}
gridData.selectedRowNumber = selectedRowNumber;	
saveGridDataStoreData(id, details, gridData);	            
	   	            ]]>
	   	        </setPropertyJavaScript>		   	                
	   	    </runtimeProperty>
	   	    
	   	    <runtimeProperty>
	   	        <type>rowCount</type>
	   	        <name>Row count</name>
	   	        <getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rows) {
		return gridData.rows.length;
	} else {
		return 0;
	}
} else {
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// return number of rows
	return grid.find("tr").length - 1;
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>	   	        
	   	    </runtimeProperty>
	   	    
	   	</runtimeProperties>
	   	
	    <designLinkJQuery>
	        <![CDATA[
.filter( function() {
	var link = $(this);
	var id = link.attr("data-id");
	var details = window[id + "details"];
	if (details && details.dataStorageType) {
		return true;
	} else {
		link.hide();
	}
}).click( function(ev) {
	showDesignData($(this));
});	        	        
	        ]]>
	    </designLinkJQuery>
	   		    
	</control>
</controls>