<?xml version="1.0" encoding="UTF-8" ?>
<controls xmlVersion="2"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="../schemas/control.xsd">

	<!-- Copyright (C) 2020 - Gareth Edwards / Rapid Information Systems gareth.edwards@rapid-is.co.uk 
		This file is part of the Rapid Application Platform Rapid is free software: 
		you can redistribute it and/or modify it under the terms of the GNU General 
		Public License as published by the Free Software Foundation, either version 
		3 of the License, or (at your option) any later version. The terms require 
		you to include the original copyright, and the license notice in all redistributions. 
		This program is distributed in the hope that it will be useful, but WITHOUT 
		ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
		FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
		You should have received a copy of the GNU General Public License in a file 
		named "COPYING". If not, see <http://www.gnu.org/licenses/>. -->

	<control>

		<type>grid</type>
		<name>Grid</name>
		<image>images/grid.svg</image>
		<helpHtml>A structure for the layout of controls according to rows and columns.</helpHtml>

		<addToNewApplications>true</addToNewApplications>

		<canUserAdd>true</canUserAdd>
		<canUserMove>true</canUserMove>
		<canUserAddPeers>true</canUserAddPeers>

		<properties>

			<property>
				<key>name</key>
				<name>Name</name>
				<changeValueJavaScript>text</changeValueJavaScript>
				<helpHtml>Name that can be given to the control. Names are used to help identify controls uniquely.</helpHtml>
			</property>

			<property>
				<key>label</key>
				<name>Form summary label</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>formText</changeValueJavaScript>
				<helpHtml>Summary label to appear at the end of the form. Leave blank to have the control and its value hidden.</helpHtml>
			</property>

			<property>
				<key>columnHeadings</key>
				<name>Column headings</name>
				<setConstructValueFunction>return true;</setConstructValueFunction>
				<changeValueJavaScript>checkbox</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Sets whether the grid will use headings or not.</helpHtml>
			</property>

			<property>
				<key>columns</key>
				<name>Columns</name>
				<setConstructValueFunction>return [];</setConstructValueFunction>
				<changeValueJavaScript>gridColumns</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Sets the different columns to be used by the grid. Multiple can be set or removed here and each can be customised.</helpHtml>
			</property>

			<property>
				<key>multiSelect</key>
				<name>Multi-select?</name>
				<setConstructValueFunction>return false;</setConstructValueFunction>
				<changeValueJavaScript>checkbox</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Whether to show a first column of checkboxes to allow multiple rows in the grid to be selected.</helpHtml>
			</property>

			<property>
				<key>dataStorageType</key>
				<name>Data store type</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","None"],["L","Local storage"],["S","Session storage"],["P","Page storage"]];
					]]>
	            </getValuesFunction>
				<helpHtml>Sets the method of data storage. Page storage is for as long as the page is open, session is for as long as the tab/window is open and local is for files to be stored locally on devices.</helpHtml>
			</property>

			<property>
				<key>scrollH</key>
				<name>Scroll horizontal</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
				<refreshHtml>true</refreshHtml>
				<refreshProperties>true</refreshProperties>
				<helpHtml>Sets the horizontal scrollbar.</helpHtml>
			</property>

			<property>
				<key>scrollWidth</key>
				<name>Width</name>
				<changeValueJavaScript>gridScrollWidth</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
			</property>

			<property>
				<key>scrollV</key>
				<name>Scroll vertical</name>
				<setConstructValueFunction>return "";</setConstructValueFunction>
				<changeValueJavaScript>select</changeValueJavaScript>
				<getValuesFunction>
	                <![CDATA[
return [["","No"],["scroll","Yes"],["auto","Auto"]];
					]]>
	            </getValuesFunction>
				<refreshHtml>true</refreshHtml>
				<refreshProperties>true</refreshProperties>
				<helpHtml>Sets the vertical scrollbar.</helpHtml>
			</property>

			<property>
				<key>scrollHeight</key>
				<name>Height</name>
				<changeValueJavaScript>gridScrollHeight</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>The total height that the table will be fixed to. Can be just a number in which case px will be added.</helpHtml>
			</property>

			<property>
				<key>fixedHeader</key>
				<name>Fixed header</name>
				<changeValueJavaScript>gridScrollFixedHeader</changeValueJavaScript>
				<refreshHtml>true</refreshHtml>
				<helpHtml>Whether the header row will not scroll with the other rows.</helpHtml>
			</property>

		</properties>

		<resources>

			<resource>
				<type>cssFile</type>
				<contents>styles/fonts/fontawesome/css/font-awesome.css</contents>
			</resource>

			<!-- Some browsers choose the tff instead of the woff so both are included -->
			<resource>
				<type>file</type>
				<contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.woff</contents>
			</resource>

			<resource>
				<type>file</type>
				<contents>styles/fonts/fontawesome/fonts/fontawesome-webfont.ttf</contents>
			</resource>

			<resource>
				<type>css</type>
				<contents>
	                <![CDATA[	                
table.grid {
	border-collapse:collapse;
}          

table.grid td {
	border: 0;
}     

table.grid span.sort {
	font-family: FontAwesome;
	margin-left: 5px;
}

div.gridScroll {
	display: inline-block;
}

div.gridScroll table {
	width: 100%;
}

div.gridScrollHeader {
	overflow-y: hidden;
	margin-right: 16px; /* space for the scroll bar */
}

div.gridScrollHeader table.grid tr:not(:first-child) {
	visibility: hidden; /* must be hidden rather than display none to still have geometry to stay in sync with body */
}

div.gridScrollBody table.grid tr:first-child {
	visibility: hidden; /* must be hidden rather than display none to still have geometry to stay in sync with header  */
}

[disabled] table.grid tr td {
	cursor: not-allowed;
}
	                ]]>
				</contents>
			</resource>

			<resource>
				<type>javascript</type>
				<contents>
	                <![CDATA[
	                
function getGridDataStoreData(id, details) {
	data = null;
	dataString = null;
	switch (details.dataStorageType) {
		case "L" :
			dataString = localStorage[_appId + id];
		break;
		case "S" :
			dataString = sessionStorage[_appId + id];
		break;
		case "P" :
			dataString = window[id + "datastore"];			
		break;
	}
	if (dataString) {
		data = JSON.parse(dataString);
		if (data) {
			if (!data.fields) data.fields = [];
			if (!data.rows) data.rows = [];
		}
	}
	return data;
}

function saveGridDataStoreData(id, details, data) {
	switch (details.dataStorageType) {
		case "L" :
			localStorage[_appId + id] = JSON.stringify(data);
		break;
		case "S" :		
			sessionStorage[_appId + id] = JSON.stringify(data);
		break;
		case "P" :
			window[id + "datastore"] = JSON.stringify(data);
		break;
	}
}	

function sortGridByColumn(ev, id, details, column, asc) {

	// check we have details and this column
	if (details && details.columns && details.columns[column]) {

		// get the grid data
		var data = getData_grid(ev, id, null, details);
			
		// get the field
		var field = details.columns[column].field;
		
		// assume data and details columns are the same
		var dataColumn = column;
		
		// check the column matches the field
		if (data.fields[column] != field) {
			// didn't match so find what it should be
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					dataColumn = i;
					break;
				}
			}	
		}
	
		// check there is data for the column
		if (data && data.rows && data.fields[dataColumn]) {
		
			// an array for all values in this column
			var sortedValues = [];
			// populate the array for each row with an object with the original index and value
			for (var i in data.rows) sortedValues.push( {index:i, value:data.rows[i][dataColumn]} );
			// determin the sort type
			switch (details.columns[column].sort) {
				// for n, turn both values into numbers and use that
				case "n" : sortedValues.sort( function(i1, i2) {
					var v1 = i1.value;
					if (v1) v1 = parseFloat(v1.replace(",",""));
					var v2 = i2.value;
					if (v2) v2 = parseFloat(v2.replace(",",""));
					return v1 - v2; 
				});			
				break;
				// d1 is uk date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make dates
						var d1 = new Date(d1Parts[2], d1Parts[1]-1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], d2Parts[1]-1, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d2 is uk month-word date format
				case "d2": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// get the months
						var months = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"];
						for (m1 in months) if (d1Parts[1].toLowerCase().substr(0,3) == months[m1]) break;
						for (m2 in months) if (d2Parts[1].toLowerCase().substr(0,3) == months[m2]) break;
						// make the dates
						var d1 = new Date(d1Parts[2], m1, d1Parts[0]);
						var d2 = new Date(d2Parts[2], m2, d2Parts[0]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d3 is us date format
				case "d3": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("/");
					var d2Parts = i2.value.split("/");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// clean the year if need be
						if (d1Parts[2].indexOf(" ") > 1) d1Parts[2] = d1Parts[2].substr(0,d1Parts[2].indexOf(" "));
						if (d2Parts[2].indexOf(" ") > 1) d2Parts[2] = d2Parts[2].substr(0,d2Parts[2].indexOf(" "));
						// make the dates
						var d1 = new Date(d1Parts[2], d1Parts[0]-1, d1Parts[1]);
						var d2 = new Date(d2Parts[2], d2Parts[0]-1, d2Parts[1]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// d4 is xml date format
				case "d1": sortedValues.sort( function(i1, i2) {
					// get the parts of the dates
					var d1Parts = i1.value.split("-");
					var d2Parts = i2.value.split("-");
					// easy one's first (null or not enough parts to contruct a date)
					if (!d1Parts || d1Parts.length < 3) {
						return 1;
					} else if (!d2Parts || d2Parts.length < 3) {
						return -1;
					} else {
						// make the dates
						var d1 = new Date(d1Parts[0], d1Parts[1]-1, d1Parts[2]);
						var d2 = new Date(d2Parts[0], d2Parts[1]-1, d2Parts[2]);
						// return their difference
						return d1.getTime() - d2.getTime();
					}
				});					
				break;
				// for c, make a new function from the sortFunction property and use that
				case "c":
					var f = new Function("item1","item2",details.columns[column].sortFunction);
					sortedValues.sort(f);				
				break;
				default : sortedValues.sort( function(i1, i2) {				
					// easy one's first
					if (i1.value == null) {				
						return 1;
					} else if (i2.value == null) {
						return -1;
					} else {
						// assume the values match
						var s = 0;
						// get both values in lower case
						v1 = i1.value.toLowerCase();
						v2 = i2.value.toLowerCase();
						// only if the two are different
						if (v1 != v2) {			
								// get the shortest length
								var l = Math.min(v1.length, v2.length);
								// loop the shortest length
								for (var i = 0; i < l; i++) {
									// check the different in ascii values
									if (v1.charCodeAt(i) > v2.charCodeAt(i)) {
										s = 1;
										break;
									} else if (v1.charCodeAt(i) < v2.charCodeAt(i)) {
										s = -1;
										break;
									}					
								}
								// if s is still zero use the length of the strings
								if (s == 0) s = v1.length - v2.length;			
						} // same check
						return s
					} // null checks					
				}); 
			}
					
			// create a new rows array
			var rows = [];
			// if asc
			if (asc) {
				// loop the returned sorted column values and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[i].index]);
			} else {
				// loop the returned sorted column values in reverse  and add into the rows array from their original position
				for (var i in sortedValues)  rows.push(data.rows[sortedValues[sortedValues.length - i - 1].index]);
			}
			// replace the data rows with the placed rows
			data.rows = rows;
			// set the sorted data
			setData_grid(ev, id, null, details, data);
		}
	}
} 

// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = -1;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row of the correct grid
	if (row[0] && row.closest("#" + id)[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
		// get the position of relevant row
		index = rows.index(row);
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// index is the row with the selected style within the grid
		index = grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(grid.find("tr.rowSelect"));			
	}
	if (index > -1) index ++;
	return index;
}

// gets the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridSelectedRow(id, ev) {
	// assume we're not going to find it
	var row = null;
	// get the target of the event
	var target = $(ev.target);
	// look for whether the target was in a grid row
	var row = target.closest("tr.rowStyle1,tr.rowStyle2");
	// check if in a row of the correct grid
	if (row[0] && row.closest("#" + id)[0]) {
		// the event occured from within a row so find the table, and the index of the row from the official rows
		var rows = row.closest("table").find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]");
		// if this was a row to be ignored, find the previous most non-ignored row
		if (row.is("[data-ignore]")) row = row.prevAll("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").first();
	} else {
		// the event occured outside a row so get the table using the id
		var grid = $("#" + id);
		// make sure it's a table
		if (!grid.is("table")) grid = grid.find("table").last();
		// row is .rowSelect
		row = grid.find("tr.rowSelect").not("[data-ignore]");			
	}
	return row;
}


// get the index of the selected row, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMultiSelectedRowNumber(id, ev, details) {
	// assume we're not going to find it
	var index = null;
	// get the table using the id
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// get any rowSelect rows
	var rows = grid.find("tr.rowSelect").not("[data-ignore]");
	// if we got some
	if (rows.length > 0) {
		// make index an array
		index = [];
		// for each row
		rows.each( function(i){
			// add to index
			index.push(grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").index(this) + 1);
		});
	}
	return index;
}

// gets the selected rows, ignoring rows without rowStyle1 and rowStyle2 which can be introduced by custom code
function getGridMutiSelectedRows(id, ev) {
	// assume we're not going to find any
	var rows = null;
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// rows have .rowSelect and not data-ignore
	rows = grid.find("tr.rowSelect").not("[data-ignore]");			
	// return
	return rows;
}

// selectively un-escapes html escape sequences which are escaped for us in in the setter .html(value), but not unescaped in the getter .html()
function getGridUnescapedValue(value) {
	return value.replace(/&lt;/,"<")
	            .replace(/&gt;/,">")
	            .replace(/&amp;/,"&");
}
           	
	                ]]>
	            </contents>
			</resource>
		</resources>

		<getHtmlFunction>
	        <![CDATA[ 
var headerHtml = "<tr" + (this.columnHeadings ? "" : " style='display:none'") + ">";
var rowHtml = "<tr><td>No columns</td></tr>";
if (this.columns.length > 0) {
	var rowHtml = "<tr>";
	if (this.multiSelect) {
		headerHtml += "<td><input type='checkbox' class='gridMultiSelectHeader'/></td>";
		rowHtml += "<td><input type='checkbox' class='gridMultiSelect'/></td>";
	}
	var columnCount = 0;
	for (var i in this.columns) {
		var column = this.columns[i];
		if (column.visible) {
			headerHtml += "<td" + (column.titleStyle ? " style='" + escapeApos(column.titleStyle) + "'" : "") + ">" + column.title;
			if (column.sort) headerHtml += "<span class='sort'>&#xf0dc;</span>";
			headerHtml += "</td>";
			if (i % 2 == 1) {
			 	rowHtml += "<td " + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">123.00</td>"
			} else {
				rowHtml += "<td" + (column.fieldStyle ? " style='" + escapeApos(column.fieldStyle) + "'" : "") + ">Data</td>"
			}
			columnCount ++;
		} else {
			headerHtml += "<td style='display:none;'>" + column.title + "</td>";
			rowHtml += "<td style='display:none;'></td>"
		}
	}
	if (columnCount == 0) {
		headerHtml += "<td>No visible columns</td>"
		rowHtml += "<td>No visible columns</td>";
	}
	headerHtml += "</tr>";
	rowHtml += "</tr>";
} else {
	headerHtml += "<td>No columns</td>"
}
	                
// check for scrolling
if (this.scrollH || this.scrollV) {
	// return a container div with the table inside
	return "<div id='" + this.id + "' style='display:inline-block;" + (this.scrollH ? "overflow-x:" + this.scrollH + ";max-width:" + this.scrollWidth + ";" : "") + "' class='gridScroll" + getStyleClasses(this) + "'><table class='grid'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table></div>";
} else {
	// return a simple table
	return "<table id='" + this.id + "' class='grid" + getStyleClasses(this) + "'>" + headerHtml + rowHtml.replace("<tr>","<tr class='rowStyle1'>") + rowHtml.replace("<tr>","<tr class='rowStyle2'>") + "</table>";
}
	        ]]>
	    </getHtmlFunction>

		<initDesignJavaScript>
	   		<![CDATA[
// upgrade any previous version styles to this version to include the header
if (this.styles && this.styles.length > 0) {
	// get the id
	var id = this.id;
	for (var i =0; i < this.styles.length; i++) {
		// get the style
		var style = this.styles[i];
		// if this is one to upgrade do so
		if (style.appliesTo == "#" + id) this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child", rules: style.rules});
		if (style.appliesTo == "#" + id + " tr:first-child td") this.styles.splice(i,1,{appliesTo: style.appliesTo + ", #" + id + "header tr:first-child td", rules: style.rules});
	}
}
	   		]]>
	   </initDesignJavaScript>

		<saveJavaScript>
	        <![CDATA[
// get our object
var table = this.object;
if (!table.is("table")) table = table.find("table").last();
// check if columns have been defined
if (this.columns && this.columns.length > 0) {
	// remove all sample rows, leaving the header row
	table.children().last().children(":not(:first)").remove();
} else {
	// if there are no columns, remove the header row as this will be populated by the fields
	table.children().last().children().remove();
}
// if we have datastorage of type P, turn off canBeUsedFromOtherPages
if (this.dataStorageType == "P") this.canBeUsedFromOtherPages = false;  
	        ]]>
	    </saveJavaScript>

		<getDetailsFunction>	        
	        <![CDATA[
var details = {type: this.type, columnHeadings:this.columnHeadings};
if (this.columns && this.columns.length > 0) {
	details.columns = [];
	for (var i in this.columns) {
		var column = this.columns[i];
		var c = {};
		if (column.visible) c.visible = column.visible;
		if (column.field) c.field = column.field;
		if (column.fieldStyle) c.style = column.fieldStyle;		
		if (column.sort) c.sort = column.sort;
		if (column.sortFunction) c.sortFunction = column.sortFunction;
		if (column.cellFunction) c.cellFunction = column.cellFunction;			
		details.columns.push(c);
	}
} 	        
if (this.styles && this.styles.length > 0) {
	details.rowHover = false;
	details.rowSelect = false;
	for (var i in this.styles) {
		var style = this.styles[i];
		if (style.appliesTo && style.appliesTo.indexOf("rowHover") > 0) details.rowHover = true;
		if (style.appliesTo && style.appliesTo.indexOf("rowSelect") > 0) details.rowSelect = true;
	}
}
// set multiSelect
if (this.multiSelect) details.multiSelect = true;
// check and set data storage
if (this.dataStorageType) {
	this.canBeUsedFromOtherPages = true;
	details.dataStorageType = this.dataStorageType;
} else {
	this.canBeUsedFromOtherPages = false;
}
// if scrollH set header and width
if (this.scrollH) {
	details.scrollH = this.scrollH;
	details.scrollWidth = this.scrollWidth;
}
// if scrollV set scroll, height, and header
if (this.scrollV) {
	details.scrollV = this.scrollV;
	details.scrollHeight = this.scrollHeight;
	details.fixedHeader = this.fixedHeader;
}
return details;
			]]>	        	        
	    </getDetailsFunction>

		<getDataFunction>
	        <![CDATA[
var data = null;
if (details) {
	// if there is a datastore and the grid is not present in the page    
	if (details.dataStorageType && !$("#" + id)[0]) {
		data = getGridDataStoreData(id, details);
		if (field && data.fields && data.rows && data.rows.length > 0) {
			for (var i in data.fields) {
				if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
					data = data.rows[0][i];
					break;
				}
			}
		}
	} else {
		// get the grid
		var grid = $("#" + id);
		// promote to last in case of fixed header
		if (!grid.is("table")) grid = grid.find("table").last();
		// get the columns from the details
		var columns = details.columns;
		// if we had no columns, must be dynamic
		if (!columns) columns = details.dynamicColumns;
		// return null if grid is empty
		if (!columns) return data;
		if (field) {
			var row = getGridSelectedRow(id, ev);
			if (row[0]) {
				for (var i in columns) {
					if (columns[i].field && columns[i].field.toLowerCase() == field.toLowerCase()) {
						data = getGridUnescapedValue(row.children(":nth(" + i + ")").html());
						break;
					}
				}
			}	    
			if (data == null && details.dataStorageType) {
				var dataStore = getGridDataStoreData(id, details);
				var rowIndex = getGridSelectedRowNumber(id, ev, details);
				rowIndex --;
				if (rowIndex > -1 && dataStore.rows && dataStore.rows.length > rowIndex) {
					for (var i in dataStore.fields) {
						if (dataStore.fields[i] && dataStore.fields[i].toLowerCase() == field.toLowerCase()) {
							data = dataStore.rows[rowIndex][i];
							break;
						}
					}
				}
			}
		} else {
			var data = {};
			data.fields = [];		
			for (var i in columns) {
				var field = columns[i].field;
				if (field !== undefined) data.fields.push(columns[i].field);		
			}
			data.rows = [];
			grid.find("tr:not(:first):not([data-ignore])").each(function(i) {
				var row = [];
				$(this).children().each(function(i) {
					if (details.multiSelect) i--;
					var value = getGridUnescapedValue($(this).html());
					if (i >= 0 && columns[i] && columns[i].field !== undefined) row.push(value);
				});
				data.rows.push(row);
			});
			// if there is a data store
			if (details.dataStorageType) {
			    // get the data from the data store
				var dataStore = getGridDataStoreData(id, details);
				// if we got one
				if (dataStore) {
					// make a field map of data from the grid to data from the dataStore
					var fieldMap = {};
					// loop the fields from the control in the page
					for (var i in data.fields) {
						// assume we can't find this field
						var found = false;
						// loop the fields from the dataStore
						for (var j in dataStore.fields) {
							// if this is the field they both have
							if (data.fields[i] && dataStore.fields[j] && data.fields[i].toLowerCase() == dataStore.fields[j].toLowerCase()) {
								fieldMap[i] = j;
								found = true;
								break;
							}							
						}
						// if not found 
						if (!found) {
							//add to dataStore fields
							dataStore.fields.push(data.fields[i]);
							// add to map
							fieldMap[i] = dataStore.fields.length - 1;
						}	
					}
					// loop the rows in the data from the grid
					for (var i in data.rows) {
						// add an empty row to the dataStore rows if there are more in the page
						if (dataStore.rows.length < i - 1) dataStore.rows.push([]);
						// if there are less cells in the rows than it's fields add more
						while (dataStore.rows[i].length < dataStore.fields.length) dataStore.rows[i].push(null);						
						// loop the fieldMap and update dataStore with values from page
						for (j in fieldMap) dataStore.rows[i][fieldMap[j]] = data.rows[i][j];						
					}
					// set data to our merged dataStore
					data = dataStore;	
				}							
			}						
		} // field check
	}
}
return data;
			]]>
	    </getDataFunction>

		<setDataJavaScript>
	        <![CDATA[
clearTimeout(window[id + "timeout"]);
window[id + "timeout"] = undefined;

// get the grid control	        
var grid = $("#" + id);
// make sure it's the tables
if (!grid.is("table")) grid = grid.find("table");
// if there are columns defined for this grid
if (details.columns) {
	// remove all rows except for the first one (the header)
	grid.find("tr:not(:first-child)").remove();
} else {
	// all rows as the header is dynamic
	grid.find("tr").remove();
	// if there is data and fields map them to dynamic coumns collections
	if (data && data.fields) details.dynamicColumns = data.fields.map(function(field) { return { visible: true, field: field }; });
}
// reset any sort indicators if not being used for sorting
grid.find("span.sort").html("&#xf0dc");
// if we have data
if (data !== undefined) {
	// make a data object
	data = makeDataObject(data, field);
	// if we have some rows to load
	if (data && data.rows) {
		// assume the grid has no row html 
		var rowsHtml = "";
		// check we have details and columns
		if (details && details.columns && data.fields) {
			// assume no columns (we're about to check)
			var columnMap = [];
			// assume no cell functions
			var cellFunctions = false;
			// loop the columns
			for (var i in details.columns) {				
				for (var j in data.fields) {
					var found = false;
					if (details.columns[i].field && data.fields[j]) {
						if (details.columns[i].field.toLowerCase() == data.fields[j].toLowerCase()) found = true;
					} else {
						if (!data.fields[j]) found = true;
					}
					if (found) {
						columnMap.push(j);
						break;
					}
				}
				// added the column to the map
				if (columnMap.length == i) columnMap.push("");
				// if we have cellFunction JavaScript, and it hasn't been turned into a function object yet
				if (details.columns[i].cellFunction) {
					// remember that we have at least one cell function
					cellFunctions = true;
					// if the cell function has not been added to the details object, do so now
					if (!details.columns[i].f) details.columns[i].f = new Function(["id", "data", "field", "details", "value"], details.columns[i].cellFunction);
				}
			}

                    // append all of the new rows in bulk - much faster!
                    grid.append(rowsHtml);

                    var addRows = function(grid, data, rowIndex) {
                        for (var chunkIndex = 0; chunkIndex < 40 && data.rows[rowIndex]; chunkIndex++, rowIndex++) {
                            // start the row object with the styling
                            var tr = document.createElement("tr");
                            tr.className = "rowStyle" + (rowIndex % 2 + 1) + (data.rowValidation && i < data.rowValidation.length && !data.rowValidation[i] ? " validation" : "");
                            // get the row
                            var row = data.rows[rowIndex];

                            // add multiselect
                            if (details.multiSelect) {
                                var td = document.createElement("td");
                                var input = document.createElement("input");
                                input.setAttribute("type", "checkbox")
                                input.className = "gridMultiSelect"
                                td.appendChild(input);
                                tr.appendChild(td);
                            }
                            // loop the row cells
                            for (var cellIndex in details.columns) {
                                // add cell with value to row
                                var td = document.createElement("td");

                                // assume the cell has no style rules from the grid details
                                var style = "";
                                // if column is not visable add display:none
                                if (details.columns[cellIndex] && !details.columns[cellIndex].visible) style += "display:none;";
                                // if column has a style add it
                                if (details.columns[cellIndex] && details.columns[cellIndex].style) style += details.columns[cellIndex].style;
                                // if there is a style rule make html attribute for it
                                if (style) td.setAttribute("style", style);

                                // assume the cell has no value
                                var value = "";
                                // get the position of this column in the data object
                                var mappedCol = columnMap[cellIndex];
                                // if we can find the column and it has data use it as the value
                                if (mappedCol && row[mappedCol] !== null) value = row[columnMap[cellIndex]];
                                // add the cell with the value
                                td.appendChild(document.createTextNode(value));
                                tr.appendChild(td);
                            }
                            grid.appendChild(tr);
                            
							// get a jquery reference to the row
							var rowObject = $(tr);
                            
                            // if there are cell functions to apply to the rows
							if (cellFunctions) {
							
								// loop columns looking for cell functions
								for (var i in details.columns) {
									// if this column has a cell function
									if (details.columns[i].f) {
										// get a reference to the cell (add 1 if multiSelect to account for this column)
										var cellObject = rowObject.children(":nth-child(" + ((details.multiSelect ? 2 : 1) + i*1) + ")");
										// get it's value
										var value = cellObject.html();
										// apply the function to the cellObject!
										details.columns[i].f.apply(cellObject,[id, data, details.columns[i].field, details, value]);
									}
								}
							}
	 
							// if we click on a row that isn't the first one
							rowObject.click( function(ev) {
								// get the row 
								var row = $(this);
								// if this grid has multiselect thhings are more confusing
								if (details.multiSelect) {
									// get the target
									var target = $(ev.target);
									// get the grid id
									var id = row.closest("[id]").attr("id");
									// get any table row click handler
									var handler = window["Event_click_" + id];
									// if we're here because we clicked the gridMultiSelect checkbox - in this case row selection is done in the input click listener, above, also do nothing is cell around the multiselect clicked
									if (!target.is("input.gridMultiSelect") && !target.children("input.gridMultiSelect")[0]) {
										// remove rowSelect class from all rows in the table
										row.parent().find("tr.rowSelect").removeClass("rowSelect");
										// add rowSelect to this row
										row.addClass("rowSelect");
										// if there is a hanlder uncheck all inputs, what happens next is the handler fires and the select row is just this one
										if (handler) $("#" + id).find("input.gridMultiSelectHeader, input.gridMultiSelect").prop("checked",false);
									}
								} else {
									// remove rowSelect class from all rows in the table
									row.parent().find("tr.rowSelect").removeClass("rowSelect");
									// add rowSelect to this row
									//row.addClass("rowSelect");
									var e = row.get(0);
									e.className = e.className + " rowSelect";
								}
							});
							
							// if there is a selected row
							if (data.selectedRowNumber && rowIndex === selectedRowNumber) rowObject.addClass("rowSelect");
                        }
                        if (data.rows[rowIndex]) {
                        	var timeoutId = setTimeout(function() { addRows(grid, data, rowIndex + 1); });
                        	window[id + "timeout"] = timeoutId;
                        } else {
                        	 if (window["Event_gridLoaded_" + id]) window["Event_gridLoaded_" + id](ev);
                        }
                    }

                    addRows(grid.get(0), data, 0);
			
		} else {

			// start the row object with the styling
			rowsHtml += "<tr" + (details.columnHeadings == false ? " style='display:none'" : "") + ">";
			// loop the fields				
			for (var i in data.fields) {
				// add cell with field to row
				rowsHtml += "<td>" +data.fields[i] + "</td>";
			}
			// close the row
			rowsHtml += "</tr>";
			
			var addRowsSimple = function(grid, rows, rowIndex) {
		        for (var chunkIndex = 0; chunkIndex < 40 && rows[rowIndex]; chunkIndex++, rowIndex++) {
		            // start the row object with the styling
		            var tr = document.createElement("tr");
		            tr.className = "rowStyle" + (rowIndex % 2 + 1);
		            // get the row
		            var row = rows[rowIndex];
		            // loop the row cells
		            for (var cellIndex in row) {
		                // add cell with value to row
		                var td = document.createElement("td");
		                td.appendChild(document.createTextNode(row[cellIndex]));
		                tr.appendChild(td);
		            }
		            grid.appendChild(tr);
	 
					// if we click on a row that isn't the first one
					$(tr).click( function(ev) {
						// get the row 
						var row = $(this);
						// if this grid has multiselect thhings are more confusing
						if (details.multiSelect) {
							// get the target
							var target = $(ev.target);
							// get the grid id
							var id = row.closest("[id]").attr("id");
							// get any table row click handler
							var handler = window["Event_click_" + id];
							// if we're here because we clicked the gridMultiSelect checkbox - in this case row selection is done in the input click listener, above, also do nothing is cell around the multiselect clicked
							if (!target.is("input.gridMultiSelect") && !target.children("input.gridMultiSelect")[0]) {
								// remove rowSelect class from all rows in the table
								row.parent().find("tr.rowSelect").removeClass("rowSelect");
								// add rowSelect to this row
								row.addClass("rowSelect");
								// if there is a hanlder uncheck all inputs, what happens next is the handler fires and the select row is just this one
								if (handler) $("#" + id).find("input.gridMultiSelectHeader, input.gridMultiSelect").prop("checked",false);
							}
						} else {
							// remove rowSelect class from all rows in the table
							row.parent().find("tr.rowSelect").removeClass("rowSelect");
							// add rowSelect to this row
							//row.addClass("rowSelect");
							var e = row.get(0);
							e.className = e.className + " rowSelect";
						}
					});
					
					// if there is a selected row
					if (data.selectedRowNumber && rowIndex === selectedRowNumber) rowObject.addClass("rowSelect");
		        }
		        if (rows[rowIndex]) {
		        	var timeoutId = setTimeout(function() { addRowsSimple(grid, rows, rowIndex + 1); });
		        	window[id + "timeout"] = timeoutId;
		        } else {
                    if (window["Event_gridLoaded_" + id]) window["Event_gridLoaded_" + id](ev);
                }
			}
			
			// append all of the new rows in bulk - much faster!
			grid.append(rowsHtml);
			
			addRowsSimple(grid.get(0), data.rows, 0);
			
		} // got details and columns and data fields							
	} // got data
	if (details && details.dataStorageType) saveGridDataStoreData(id, details, data);
		
	// if we vertical scrolling
	if (details && details.scrollV && details.scrollHeight) {
	
		// get scroll height
		var scrollHeight = details.scrollHeight.trim();
		// add px if no other unit specified
		if (parseInt(scrollHeight)+'' == scrollHeight+'') scrollHeight += "px";
	
		// if we have a fixed header
		if (details.fixedHeader) {
		
			// if we haven't applied it yet
			if (!grid.parent().is(".gridScrollBody")) {
		
			    // create and style the wrapper
			    var oTblDiv = $("<div class='gridScrollBody' />");
			    oTblDiv.css({
			    	"max-height": scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // wrap it
			    grid.wrap(oTblDiv);
			    
			    /*
			    
			    Not sure this and the setting below are neccessary due to the full clone

			    // save original column widths			    			    
			    grid.find('thead tr td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    }); 
			    grid.find('tbody tr:eq(0) td').each(function(){
			        $(this).attr("data-item-original-width",$(this).width());
			    });
			    
			    */                 
			
			    // clone the original grid
			    var newTbl = grid.clone();
			    // update it's id
			    newTbl.attr("id",id + "header");
			    				
				// set the class on the parent on the new table (this is the grid root)
			    newTbl.parent().addClass("gridScroll");	      
				// get the old table parent
			    var parent = grid.parent();
				// add the new table
			    parent.parent().prepend(newTbl);			    
			    // move the old table parent after the new table
			    parent.insertAfter(newTbl);
			    // wrap the new table
			    newTbl.wrap("<div class='gridScrollHeader' />")

				/*
			    				    			
			    // replace original column widths
			    newTbl.find('thead tr td').each(function(){
			    	var w = $(this).attr("data-item-original-width");
			        if (w) $(this).width(w);
			    });     
			    grid.width(grid.attr('data-item-original-width'));      
			    grid.find('tbody tr:eq(0) td').each(function(){
			    	var w = $(this).attr("data-item-original-width");
			        $(this).width(w);
			    });
			    
			    */
			    
			    // positioning the header has been moved to the init on window resize
			    
			} // fixed header applied
		    
		} else {
		
			// check not applied already
			if (!grid.parent().is(".gridScrollApplied")) {

				// remove the table id
				grid.removeAttr("id")
				// create and style the wrapper
			    var oTblDiv = $("<div class='gridScroll' id='" + id + "' />");
			    oTblDiv.css({
			    	"max-height": scrollHeight,
			    	"overflow-y": details.scrollV
			    });
			    // retain that we have applied the scroll
			    oTblDiv.addClass("gridScrollApplied");
			    // wrap it
			    grid.wrap(oTblDiv);
			    
			} // v scroll applied check
		
		} // fixed header
				
	} // vertical scrolling
	
	// if have not applied sorts yet
	if (details && !grid.parent().is(".gridSortsApplied")) {
	
		// assume no headers
		var headers = null;
		// if there is vertical scrolling
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			// get the visible header cells
			headers = $("#" + id).find("table").first().find("tr:first-child td");
		} else {
			headers = grid.find("tr:first-child td");
		}
	
		// loop the columns
		for (var i in details.columns) {
			// if it has a sort (but not a fuxed)
			if (details.columns[i].sort) {
				// assume the index is i
				var index = i;
				// if we have multiselect move the index on one
				if (details.multiSelect) index ++;
				// get the header cell - move one on if we have multiselect
				var cell = $(headers.get(index));
				// change the cursor
				cell.css("cursor","pointer");
				// add a listener
				cell.click( {index:index},function(ev) {
					// get the span
					var span = $(ev.target);
					// drill down if need be
					if (!span.is("span")) span = span.find("span");
					// get the column
					var column = ev.data.index;
					// if this is multiselect subtract 1 column
					if (details.multiSelect) column--;
					// if ascending or not set (note the unicode escape)
					if (span.html() == "\uf0de") {
						sortGridByColumn(ev, id, details, column, false);
						span.html("&#xf0dd;");
					} else {
						sortGridByColumn(ev, id, details, column, true);
						span.html("&#xf0de;");
					}
				});
			}
		}
		
		// mark grid as having sorts applied
		grid.parent().addClass("gridSortsApplied");
	
	}
	
	// if we have multiSelect
	if (details.multiSelect) {
		// fixed header clones the header and the checkbox in it so we need to put the header checkbox listener back
		if (details.scrollV && details.scrollHeight && details.fixedHeader) {
			$("#" + id).find("input.gridMultiSelectHeader").click(function(ev){
				// get the header value
				var select = $(this).prop("checked");
				// update rowSelect accordingly
				if (select) {
					// put rowSelect class on all rows expect for the top one, as it's the header
					grid.find("tr:not(:first-child)").addClass("rowSelect");
				} else {
					grid.find("tr").removeClass("rowSelect");
				}
				// update row checkboxes
				grid.find("input.gridMultiSelect").prop("checked",select);
			});
		}
		// listen for rows checkbox - needs to be click to beat the listener on the row, and use id in case of fixed header
		$(grid).find("input.gridMultiSelect").click(function(ev){
			// get the input
			var i = $(this);
			// get the value
			var select = i.prop("checked");
			// add or remove class accordingly
			if (select) {
				i.closest("tr").addClass("rowSelect");
			} else {
				i.closest("tr").removeClass("rowSelect");
			}
			// check whether any rows without rowSelect, if not uncheck header checkboxs (includes if fixed header)
			if (grid.find("tr.rowStyle1,tr.rowStyle2").not("[data-ignore]").not(".rowSelect").length > 0) $("#" + id).find("input.gridMultiSelectHeader").prop("checked",false);
		});
	}
	
	// apply the resizing	
	$(window).resize();
	
}
			]]>
	    </setDataJavaScript>

		<events>
			<event>
				<type>click</type>
				<name>Row click</name>
				<filterFunction>
<![CDATA[
var target = $(ev.target);
// don't fire if any ancestor is disabled
if (target.closest("[disabled]")[0]) return true;
// don't fire if the target is the top row or tbody, but allow the multi select
if ((target.closest("tr").index() == 0 || target.is("tbody")) && !target.is("input.gridMultiSelectHeader")) return true;
// don't fire if the target is the cell around the multiselect
if (target.is("td:first-child") && target.children("input.gridMultiSelect")[0]) return true;
]]>	                
	            </filterFunction>
			</event>
			<event>
				<type>gridLoaded</type>
				<name>Loaded</name>
				<filterFunction>
<![CDATA[

]]>	                
	            </filterFunction>
			</event>
		</events>

		<styles>
			<style>
				<name>Grid</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + ", #" + this.id + "header";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Title row</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child, #" + this.id + "header tr:first-child";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Title cells</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:first-child td, #" + this.id + "header tr:first-child td";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row cells</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:not(:first-child) td";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row style 1</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle1";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row style 2</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowStyle2";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row hover</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " tr:hover:not(:first-child)";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
			<style>
				<name>Row select</name>
				<getAppliesToFunction>
					<![CDATA[	      
return "#" + this.id + " .rowSelect";
	       			 ]]>	                
	            </getAppliesToFunction>
			</style>
		</styles>

		<initJavaScript>
	        <![CDATA[
// get the grid
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();     
// check there are details	        
if (details) {

	// if this is a fixed header
	if (details.scrollV && details.fixedHeader) {
	
		// listen for a window resize - sent after grid population and when some controls are made visible
		$(window).on('resize', function(){

			// only if grid is visible and a scroll body has been set up for it
			if (grid.is(":visible") && grid.parent().is("div.gridScrollBody")) {
				// get the header table
				var headerTable =  $("#" + id).find("table").first();			
				// get the header hight
				var headerHeight = headerTable.find("tr:first-child").height();
				// set height of the header table wrapper
				headerTable.parent().css({"height":headerHeight});
				// shift the second table up behind the fixed header
				grid.css("margin-top",-headerHeight);
			}

		});
	
	}
	// if this is multiSelect, set up the header checkbox listener
	if (details.multiSelect) {
		$("#" + id).find("input.gridMultiSelectHeader").change(function(ev) {
			// get the header value
			var select = $(this).prop("checked");
			// update rowSelect accordingly
			if (select) {
				grid.find("tr").addClass("rowSelect");
			} else {
				grid.find("tr").removeClass("rowSelect");
			}
			// update row checkboxes
			grid.find("input.gridMultiSelect").prop("checked",select);
		});
	}
	// if there is a data store
	if (details.dataStorageType) {
		var data = getGridDataStoreData(id, details);
		if (data) setData_grid($.Event('gridinit'), id, null, details, data);
		$("#" + id).click( function(ev) {
			// get the data
			var data = getGridDataStoreData(id, details);
			// if there was some
			if (data) {
				// if multiSelect
				if (details.multiSelect) {
					// get multi selected rows
					data.selectedRowNumber = getGridMultiSelectedRowNumber(id, ev, details);
				} else {
					// get a single selected row
					data.selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
				}
				// save
				saveGridDataStoreData(id, details, data);
			}
		});
	} // datastorage type check
	
	// get the rapid form - it will always have an id and a POST method. Forms in the page from the theme typically don't have the id. If grid data is not being retained in Rapid forms, it may be that duplicate controls are being added to other forms from the theme
	var form = $("form[id][method=POST]");
	// if there was one
	if (form[0]) {
		// add a hidden form input for the grid
		form.append("<input id='" + id + "data' name='" + id + "' type='hidden'/>");
		// listen for form submit and use getData_grid(ev, id, null, details)
		form.submit(function(ev){
			// get grid data and stringify with JSON.stringify
			var jsonData = JSON.stringify(getData_grid(ev, id, null, details));
			// put into our data input which has the name of the control so should be included in the form post
			$("#" + id + "data").val(jsonData);
		});
		
	}
	
} 
	        ]]>	        
	    </initJavaScript>

		<runtimeProperties>

			<runtimeProperty>
				<type>selectedRowData</type>
				<name>Selected row data</name>
				<getPropertyFunction>
			        <![CDATA[
var data = null;
var columns = details.columns || details.dynamicColumns || [];
if (details.dataStorageType) {
	data = getGridDataStoreData(id, details);
	if (data && data.fields && data.rows) {
		var grid = $("#" + id);
		if (!grid.is("table")) grid = grid.find("table").last();
		if (grid[0]) {
			var rowNumber = null;
			if (details.multiSelect) {
				rowNumber = getGridMultiSelectedRowNumber(id, ev, details);
			} else {
				rowNumber = getGridSelectedRowNumber(id, ev, details);
			}
			if (data && rowNumber != data.selectedRowNumber) {
				data.selectedRowNumber = rowNumber;
				saveGridDataStoreData(id, details, data);
			}
		}
		rows = [];
		if (data && data.selectedRowNumber) {
			if (details.multiSelect && $.isArray(data.selectedRowNumber)) {
				for (var i in data.selectedRowNumber) {
					rows.push(data.rows[data.selectedRowNumber[i] - 1]);
				}
			} else {
				if (data.selectedRowNumber > -1) rows.push(data.rows[data.selectedRowNumber - 1]);
			}		
		}
		data.rows = rows;
	}
} else {
	if (details.multiSelect) {
		var rows = getGridMutiSelectedRows(id, ev);
		if (rows && rows.length > 0) {
			data = {fields:[],rows:[]};
			for (var i = 0; i < rows.length; i++) {
				// get a jQuery wrapper for the row element
				var row = $(rows[i]);
				// prepare a data row
				var dataRow = [];
				// loop the columns
				for (var j = 0; j < columns.length; j++) {
					// add fields once only
					if (i == 0) data.fields.push(columns[j].field);
					// get cell html  - one over because of the checkbox
					// unescape
					var value = getGridUnescapedValue(row.children(":nth(" + (j + 1) + ")").html());
										
					// add unescaped cell html to datarow
					dataRow.push(value);
				}
				// add datarow to row
				data.rows.push(dataRow);
			}
		}
	} else {
		var row = getGridSelectedRow(id, ev);
		if (row[0]) {
			data = {fields:[],rows:[[]]};
			for (var i in columns) {
				data.fields.push(columns[i].field);
				// get cell html
					// unescape
				var value = getGridUnescapedValue(row.children(":nth(" + i + ")").html());
				// add unescaped cell html to datarow
				data.rows[0].push(value);
			}
		}
	}
}
// if we were provided with a field to drill into the row data
if (field && data && data.fields && data.rows && data.rows.length > 0) {
	// assume we can't find the field
	var fieldIndex = -1;
	// loop the fields
	for (var i in data.fields) {
		// if there is a field at this position and it case-insentively matches what we're looking for
		if (data.fields[i] && data.fields[i].toLowerCase() == field.toLowerCase()) {
			// remember we found it
			fieldIndex = i;
			// we're done
			break;
		}
	}
	// if we found it
	if (fieldIndex > -1) {
		// check multiSelect
		if (details.multiSelect) {
			// create complex data object if so
			var multiRowData = {fields:[field],rows:[]};
			// loop rows - non multi select will have only 1
			for (var i in data.rows) {				
				// get the value
				var value = data.rows[i][fieldIndex];
				// add an empty row array
				multiRowData.rows.push([]);
				// put the value in the row array
				multiRowData.rows[i].push(value);
			}
			// set the data we're returning to what we just made
			data = multiRowData;
		} else {
			// get the value from the first row
			data = data.rows[0][fieldIndex];
		}
	} else {
		// could not find field
		data = null;
	}
}
return data;
			        ]]>      
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
// assume no grid data
var gridData = null;
// get the grid select row number which priorities grid in page then data
var rowNumber = getGridSelectedRowNumber(id, ev, details);
// get the grid object
var grid = $("#" + id);
// if we had one in the page
if (grid[0]) {
	// promote to last grid in the case of fixed headers
	if (!grid.is("table")) grid = grid.find("table").last();
	// get data from the page
	gridData = getData_grid(ev, id, null, details);
	// set the row number
	gridData.selectedRowNumber = rowNumber;
	// save the grid data store data (if applicable)
	saveGridDataStoreData(id, details, gridData);
} else {
	// grid not in page so go straight for data store
	gridData = getGridDataStoreData(id, details);
}
data = makeDataObject(data, field);
// check we have grid data and a selected row
if (gridData && gridData.selectedRowNumber && gridData.selectedRowNumber > 0) {
	// replace or remove selected row	
	if (data && data.fields && data.rows && data.rows.length > 0) {
		// get the gridData fields
		var gridDataFields = gridData.fields;
		// check there are some
		if (gridDataFields) {
			
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}			
			// loop the incoming fields one more time
			for (var i in data.fields) {
				// add an entry at this position if we need one
				if (gridData.rows[gridData.selectedRowNumber - 1].length < data.fields.length) gridData.rows[gridData.selectedRowNumber - 1].push(null);
				// update the selected row field from the map
				gridData.rows[gridData.selectedRowNumber - 1][fieldMap[data.fields[i]]] = data.rows[0][i];
			}			
		} else {
			// take them from the incoming data object
			gridData.fields = data.fields;
			// put top row of what we were passed into selected row
			gridData.rows[gridData.selectedRowNumber - 1] = data.rows[0];
		}		
	} else {
		// remove the selected row 
		gridData.rows.splice(gridData.selectedRowNumber - 1, 1);
		// remove the validation entry if present
		if (gridData.rowValidation) gridData.rowValidation.splice(gridData.selectedRowNumber - 1, 1); 
		// remove the selection
		gridData.selectedRowNumber = null;
	}
	// if there is a datastore to save the data to
	if (details && details.dataStorageType) {
		// if the grid is visible in the page
		if ($("#" + id)[0]) {
	  		// update the grid with the gridData (which will save as well)
	  		setData_grid(ev, id, field, details, gridData, changeEvents);
	  	} else {
	  		// just save the grid
	  		saveGridDataStoreData(id, details, gridData);
	  	}
	} else {
		// update the grid with the gridData (which will save as well)
	  	setData_grid(ev, id, field, details, gridData, changeEvents);
	}
} else {
	// append if no selected row
	if (data) {
		// create a rows array if not present
		if (!gridData.rows) gridData.rows = [];
		// look for existing fields
		if (gridData.fields) {
		
			// set up a field map which will hold the location of the incoming fields in the grid fields
			var fieldMap = {};
			// loop the incoming fields
			for (var i in data.fields) {
				// get it's name
				var field = data.fields[i];
				// assume it wasn't found in the grid's list of fields	
				var foundField = false;							
				// loop the grid's fields
				for (var j in gridData.fields) {
					// if there's a match					
					if (field.toLowerCase() == gridData.fields[j].toLowerCase()) {
						// store it's position
						fieldMap[field] = j;
						foundField = true;
						break;
					}
				}
				// if the field wasn't found in the grid
				if (!foundField) {
					// add it to the grid's fields
					gridData.fields.push(field);
					// retain the position
					fieldMap[field] = gridData.fields.length - 1;
				}				
			}
			
			// make a row
			var row = [];
			// add the cells
			while (row.length < gridData.fields.length) row.push(null);
			// loop the data fields and use the map to get the correct position
			for (var i in data.fields) {
				// get the field
				var field = data.fields[i];
				// get the position
				var pos = fieldMap[field];
				// add it to the correct place in the row
				row[pos] = data.rows[0][i];
			}
			// add the row to the gridData
			gridData.rows.push(row);
		
		} else {
			
			// assume the incoming fields		
			gridData.fields = data.fields;
			// add the top row of what we were given
			gridData.rows.push(data.rows[0]);
		
		}
		
		// set the selected row number
		gridData.selectedRowNumber = gridData.rows.length;
		// save the grid
		saveGridDataStoreData(id, details, gridData);
		// if the grid is visible, refresh it
		if (grid[0]) setData_grid(ev, id, null, details, gridData, changeEvents);
	}	
}	   	            
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>

			<runtimeProperty>
				<type>selectedRowValidation</type>
				<name>Selected row validation</name>
				<getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rowValidation && gridData.selectedRowNumber) {
		return gridData.rowValidation[gridData.selectedRowNumber - 1];
	} 
} else {
	return getGridSelectedRowNumber(id, ev, details);
}
return null;
			        ]]>	  	   	            
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
	   	            
var data = makeDataObject(data, field);
var selectedRowNumber = null;

// look for the grid on this page
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
// if it's present
if (grid[0]) {
	// get the selected row number
	selectedRowNumber = getGridSelectedRowNumber(id, ev, details);
	// check the incoming data for a positive
	if (data[0][0]) {
		// remove validation class from row if true
		grid.find("tr.rowSelect").removeClass("validation");
	} else {
		// add validation class to row if false
		grid.find("tr.rowSelect").addClass("validation");
	}
}
	            	   	            
if (details && details.dataStorageType) {
	// get the grid data
	gridData = getGridDataStoreData(id, details);
	// make an object if there isn't one
	if (!gridData) gridData = {};
	// if we got a row number from the grid put it into the grid now
	if (selectedRowNumber) gridData.selectedRowNumber = selectedRowNumber;
	// if there are rows and one is selected
	if (gridData.rows && gridData.selectedRowNumber) {
		// add a rowValidation collection if there isn't one
		if (!gridData.rowValidation) gridData.rowValidation = [];
		// ensure the rowValidation collection is the same size as the row collection
		while (gridData.rows.length > gridData.rowValidation) gridData.rowValidation.push(true);
		// set the validation
		gridData.rowValidation[gridData.selectedRowNumber - 1] = data.rows[0][0];
		// save the grid
		saveGridDataStoreData(id, details, gridData);
	}
} 
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>

			<runtimeProperty>
				<type>selectedRowNumber</type>
				<name>Selected row number</name>
				<getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.selectedRowNumber) {
		return gridData.selectedRowNumber;
	} else {
		return null;
	}
} else {
	return getGridSelectedRowNumber(id, ev, details);
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>
				<setPropertyJavaScript>
	   	            <![CDATA[
gridData = getGridDataStoreData(id, details);
if (!gridData) gridData = {fields:[],rows:[]};
data = makeDataObject(data, field);
var selectedRowNumber = null;
var grid = $("#" + id);
// make sure it's a table
if (!grid.is("table")) grid = grid.find("table").last();
if (grid) grid.find("tr.rowSelect").removeClass("rowSelect");
if (data) {
	selectedRowNumber = data.rows[0][0];
	if (grid) grid.find("tr:eq(" + selectedRowNumber + ")").addClass("rowSelect");
}
gridData.selectedRowNumber = selectedRowNumber;	
saveGridDataStoreData(id, details, gridData);	            
	   	            ]]>
	   	        </setPropertyJavaScript>
			</runtimeProperty>

			<runtimeProperty>
				<type>rowCount</type>
				<name>Row count</name>
				<getPropertyFunction>
			        <![CDATA[
if (details && details.dataStorageType) {
	var gridData = getGridDataStoreData(id, details);
	if (gridData && gridData.rows) {
		return gridData.rows.length;
	} else {
		return 0;
	}
} else {
	// get the grid
	var grid = $("#" + id);
	// make sure it's a table
	if (!grid.is("table")) grid = grid.find("table").last();
	// return number of rows
	return grid.find("tr").length - 1;
}
			        ]]>	  	   	            
	   	        </getPropertyFunction>
			</runtimeProperty>

		</runtimeProperties>

		<designLinkJQuery>
	        <![CDATA[
.filter( function() {
	var link = $(this);
	var id = link.attr("data-id");
	var details = window[id + "details"];
	if (details && details.dataStorageType) {
		return true;
	} else {
		link.hide();
	}
}).click( function(ev) {
	showDesignData($(this));
});	        	        
	        ]]>
	    </designLinkJQuery>

	</control>
</controls>